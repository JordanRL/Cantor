{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } Using This Documentation A best effort is made to keep this documentation current, and the entire documentation is reviewed before every tagged release, however the documentation under v:latest may at times be out of date or incomplete. Why Use Fermat? To understand why this library might be useful in comparison to alternatives, please see the Fermat vs. Alternatives page. Info Boxes Additional information is provided throughout this documentation using color coded information boxes. These are the styles used and what they are used for. Notes This type of box is used to provide additional notes about a topic that may be rare use cases, or more detailed technical information that is not relevant to all readers of this documentation. Tips This type of box is used to give helpful tips on using the code described in the section where it appears. Sometimes this may be tips on architecture, while others it could be a tip on how to improve performance or help accomplish a common task. Examples This type of box is used to provide examples of code, inputs, and outputs that illustrate a point which may be difficult to explain using just words. See Also This type of box is used to point you towards other parts of this documentation, or documentation elsewhere on the internet, which might provide more information on the section being described. Potential Bugs This type of box is used to provide a warning about common ways a programmer using this library might introduce a bug into their software through this library. It often details potentially unexpected type conversions, assumptions made that may not be obvious, or limitations that are inherent to this library or to PHP. Cautions This type of box is used to caution the developer about incorrect usage of the section being detailed. It is used when the incorrect usage will not result in exceptions or unexpected results, but instead might simply have undesirable side effects. Warnings This type of box is used to warn the developer about incorrect usage of the section being detailed. It is used when the incorrect usage will result in exceptions, but not unexpected results. Danger This type of box is used to alert the developer about potentially hard to find bugs that will result from an incorrect usage of the section being detailed. It is used when the incorrect usage will result in unexpected result without any exceptions or errors. What This Library Is For Consistent arbitrary scale math Provides a consistent way to perform arbitrary scale math without making it easy to accidentally use PHP features (such as arithmetic operators or built in functions) that will reduce scale by casting to native int or float types. This is accomplished by providing an arbitrary scale implementation of all math functions which might be performed on a variable with the integer or float types. Complex math functions Enables the use of common complex math tasks, such as working with basic statistics functions, while still preserving arbitrary scale. Non-Integer & non-float number types Provides a framework for working with non-integer and non-float math concepts such as fractions, coordinates, imaginary numbers, and complex numbers. Abstraction of math concepts Provides a consistent abstraction for nearly any math concept that is likely to be relevant to a computer program, including many scientific programs. What This Library Is NOT For Extreme Performance While Fermat has different modes that allow you to control performance to a degree, the abstraction and comprehensive nature of the library means that for certain uses, such as working with complex numbers, a large number of object instances may be created temporarily during a calculation, leading to significantly more overhead than using operands directly when doing basic math within common scale limitations. Despite the fact that performance is not a primary goal of this library, it does use built in functions wherever possible (where doing so does not affect scale), and it will utilize the GMP functions and PHP-DS types if those extensions are present in your installation of PHP. Installing these extensions should slightly increase performance in most use-cases. Tip A good way to increase performance is to avoid using imaginary and complex numbers if possible. The actual math involved in calculating simple operations involving these values is algorithmically complex, and leads to much longer execution times. Installing the suggested extensions will also help improve performance, in some situations quite significantly. Other Extensions Like many programs, this library's performance suffers enormously if xDebug is enabled. This can lead to execution times of more than one second for a single operation on complex numbers, making them almost totally unusable for the web. To avoid this, make sure that your production environment does not have xDebug enabled. Integration With Other Math Libraries Everything is self-contained within this library, and if you need to use another math library or a built-in math function to accomplish something, please create a GitHub issue so that it can be added to the library. Keep in mind that this library is not necessarily designed to guarantee compatibility. That said, this library does offer ways for you to integrate. The state of all objects is available for reading at all times enabling you to put data into other libraries or functions, and the classes are all left open for extension. The references within the library are almost all to a base abstract class or interface, making it easier for a developer to extend a class with their own code. Limitations Developers using this library should be aware of the following limitations which may lead to unexpected results. Extreme Scale While this library can theoretically handle scales on all operations up to 2 63 2^{63} 2 63 digits, in practice there are many operations in this library that have practical limits because of execution time. For instance, while the library would faithfully collect the first 10,000 digits of sin \u2061 ( 1 ) \\sin(1) sin ( 1 ) , doing so may take prohibitively long, and depending on configuration and environment, the process may be killed before completion as a 'hung' process. There are also several features in this library that by the nature of the math behind them can lead to infinite loops with the wrong inputs. While some basic measures exist within the library to detect and exit these situations with a thrown exception, doing so comprehensively is an example of the halting problem. This should not occur without direct calls to these areas, such as SeriesProvider::maclaurenSeries() . Avoid Direct Usage While the SeriesProvider methods are public, and can certainly be used directly, the internal workings of the functions are complicated to understand and simple to get wrong. In general, you should try to use consumers of the SeriesProvider first, such as the various distributions, or the StatsProvider . For this reason, you should limit your requested scale to the smallest value which will still work for your intended application. Some Types of Math Require Assumptions Some areas of math are ambiguously defined, depending on the exact axioms used. More generally, there are some types of calculations which give consistent behavior for a variety of axioms and mappings, or for which there is no consistent behavior defined within mathematics. This is most obvious in the arc functions, such as arctan \u2061 ( x ) \\arctan(x) arctan ( x ) . However, other areas make assumptions that may not be entirely clear at first. For Example Calling isEqual() on a ComplexNumber will return false unless it is being compared to another ComplexNumber that has the same values for its real and imaginary part. More surprisingly perhaps, ComplexNumber objects do not have any of the GreaterThan or LessThan functions, as inequality comparison is poorly defined even between two complex numbers. These peculiarities are documented as accurately as possible in this documentation where they occur. Immutables Are Used Internally While this library provides both Mutable and Immutable versions of its base values, when a new object is generated internally it is nearly always an immutable version. This is to limit the side effects that might occur if object instance zvals that were used internally were changed in a parent scope. Because of this, methods which return a calculated value object always return the Immutable version of that value. For this same reason, most of the time when an object is returned from an internal register, such as with the getNumerator() method on Fraction , any changes to that object will not be reflected in the instance of Fraction that it came from. The exceptions to this are objects which contain a register of registers. An example would be the Matrix class, which internally has an array of NumberCollection objects. To prevent side effects in this situation, a clone is returned instead when the object is accessed with getRow() or getColumn() . However, methods which act as array manipulation tools, such a popRow() and shiftColumn() will return the actual instance, and directly affect the internal data values. This is related to PHP's internal structure of hashtables and zvals, and how these interact with the object model that PHP uses. See Also The PHP Documentation contains examples on the specifics of how objects are passed between scopes. While it isn't exactly the same as passing by reference, it behaves in a very similar way in most situations. See the php.net page for more information. See Also More information about mutable and immutable objects, as well as how they are implemented and used with this library, is available on the Mutable vs. Immutable documentation page. This Library Can't Be Reliably Used With Math Operators Because PHP doesn't allow operator overloading, using the native math operators on Fermat objects directly can very easily result in loss of scale, overflows and underflows, PHP fatal errors (f.e. when the object is in a non-base-10 format), and incorrect calculation (f.e. with complex and imaginary numbers). Non-Base-10 Values With Native Operators Using a value that is in a base larger than base-10 with math operators can result in PHP fatal errors. For instance, the value 15 in base 16 will output the string F . When used with the operator / as the value on the right of the operator, this would result in a \"Division by Zero\" PHP fatal error. This occurs because PHP will attempt to cast the string F to an integer , which will result in the value 0 . Complex Numbers With Native Operators Using a ComplexNumber instance with native operators will throw only a notice and discard the imaginary component, making it very difficult to pin down the source of the incorrect result if notices are not turned on with the E_NOTICE or E_ALL levels in php.ini . 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableComplexNumber ; 4 5 $complexNumber = ImmutableComplexNumber :: makeFromString ( '2+2i' ); 6 7 echo $complexNumber + 2 ; 8 // Prints: 4 9 // Issues: PHP Notice","title":"Introduction"},{"location":"#using-this-documentation","text":"A best effort is made to keep this documentation current, and the entire documentation is reviewed before every tagged release, however the documentation under v:latest may at times be out of date or incomplete. Why Use Fermat? To understand why this library might be useful in comparison to alternatives, please see the Fermat vs. Alternatives page.","title":"Using This Documentation"},{"location":"#what-this-library-is-for","text":"","title":"What This Library Is For"},{"location":"#what-this-library-is-not-for","text":"","title":"What This Library Is NOT For"},{"location":"#limitations","text":"Developers using this library should be aware of the following limitations which may lead to unexpected results.","title":"Limitations"},{"location":"fermat-vs-alternatives/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } Comparing Fermat To Alternatives This page covers the situations in which Fermat provides clear advantages over alternative ways to get arbitrary precision math in PHP. Advantages Compared To Extensions There are several advantages to using Fermat compared to the two arbitrary precision extensions (ext-bcmath and ext-decimal) directly. Support For BCMath Is Already Part Of Fermat At its core, Fermat utilizes the BCMath extension (which is included by default in modern installations of PHP) to perform the base calculations. You don't gain anything by using the BCMath library directly, as this would result in needing to manually and directly manage things like changes in scale. All of the BCMath operations are still accessible using Fermat with the ArithmeticProvider , which functions as a formatting wrapper for the BCMath library. Fermat Provides More Complex Math Operations While ext-bcmath and ext-decimal provide the speed of a PHP extension, this benefit only applies when performing simply arithmetic. When such simple operations are being performed, Fermat is similarly fast. The power of Fermat is its support for both arbitrary precision and more complex operations, such as basic , hyperbolic , and inverse trigonometry functions, e x e^x e x and l n ( x ) ln(x) l n ( x ) functions, and fractions . Fermat Provides Even More Math Through Modules On top of the extra functionality that Fermat provides in comparison to ext-bcmath and ext-decimal, more functionality is available through Fermat Modules . Some of these, such as the statistics functions provided by Fermat Stats , are not available via PHP extensions even for non-arbitrary math. Fermat Provides a Consistent Developer Experience By providing objects which have a fluent interface and are aware of how the rest of the library works, the developer experience is incredibly consistent. You can always use the add() method to add two numbers. You can always ask for the tangent with tan() . If the library needs additional help to complete your requested operation, the exception model makes it easy for your program to recover and in many cases even retry the operation. Advantages Compared to Other Libraries There are other libraries that provide arbitrary precision math, or provide complex mathematical functions. This is the only PHP library that provides both. Compared to brick/math This library does a fantastic job of providing a similarly fluent and consistent developer experience for dealing with arbitrary precision math, however it is limited to only the basic arithmetic which can be performed via the ext-bcmath extension. Additionally, while the brick/math library provides only immutable values, (which to be fair are almost always better for performing mathematical operations, see Mutable vs. Immutable ), Fermat supports both mutable and immutable varieties of its values. The lack of more complex mathematical operations in brick/math also prevents it from supporting some of the extra features available in Fermat through modules . Statistics functions require both e x e^x e x and l n ( x ) ln(x) l n ( x ) implementations in order to be possible for instance, while math with complex numbers requires implementations of both s i n ( x ) sin(x) s in ( x ) and c o s ( x ) cos(x) cos ( x ) .","title":"Fermat vs. Alternatives"},{"location":"fermat-vs-alternatives/#comparing-fermat-to-alternatives","text":"This page covers the situations in which Fermat provides clear advantages over alternative ways to get arbitrary precision math in PHP.","title":"Comparing Fermat To Alternatives"},{"location":"fermat-vs-alternatives/#advantages-compared-to-extensions","text":"There are several advantages to using Fermat compared to the two arbitrary precision extensions (ext-bcmath and ext-decimal) directly.","title":"Advantages Compared To Extensions"},{"location":"fermat-vs-alternatives/#advantages-compared-to-other-libraries","text":"There are other libraries that provide arbitrary precision math, or provide complex mathematical functions. This is the only PHP library that provides both.","title":"Advantages Compared to Other Libraries"},{"location":"arithmetic/","text":"Working With NumberInterface Arithmetic can be performed on any class that implements the NumberInterface , and the rules for using arithmetic methods are consistent and straight-forward: you can put any value that is valid for an ImmutableNumber constructor in, or you can put in any instance of an object that implements NumberInterface itself. You Might Not Expect If two objects which have different calculation modes are used in an arithmetic operation, the calculation mode of the object which makes the function call is used, and the calculation mode of the object supplied as an argument is ignored. Additionally, the object returned will be of the same class as the object making the function call if that is possible. This means that fractions will be converted to decimals when they are the argument for a decimal function call, or visa versa. If the result must be represented in a particular way, such as with complex numbers, the returned value will be the immutable version of the class that can respresent the result. This means adding two classes that implement DecimalInterface can return a class that implements ComplexNumberInterface if one is an imaginary number, and one is a real number. The following arithmetic methods are available. add(int|float|numeric|NumberInterface $num): self This adds the argument to the Value using the ArithmeticProvider or the native + operator depending on the calculation mode of the original object. When an object that implements DecimalInterface and another that implements FractionInterface are added together, the one that is provided as an argument is coerced into the type of original object. The result is returned as an instance of a value object, depending on the result of the calculation. subtract(int|float|numeric|NumberInterface $num): self This subtracts the argument from the Value using the ArithmeticProvider (which uses the BCMath library internally) and returns the newly calculated Value. When an object that implements DecimalInterface and another that implements FractionInterface are subtracted, the one that is provided as an argument is coerced into the type of original object. For example: 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $five = new ImmutableNumber ( 5 ); 7 $oneQuarter = new ImmutableFraction ( 1 , 4 ); 8 9 echo $five -> subtract ( $oneQuarter ); // Prints: \"4.75\" 10 // The asDecimal() method is called on $oneQuarter 11 12 echo $oneQuarter -> subtract ( $five ); // Prints: \"-19/4\" 13 // Calls getValue() on $five and instantiates a new ImmutableFraction multiply(int|float|numeric|NumberInterface $num): self This multiplies the argument from the Value using the ArithmeticProvider (which uses the BCMath library internally) and returns the newly calculated Value. When an object that implements DecimalInterface and another that implements FractionInterface are multiplied, the one that is provided as an argument is coerced into the type of original object. For example: 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $five = new ImmutableNumber ( 5 ); 7 $oneQuarter = new ImmutableFraction ( 1 , 4 ); 8 9 echo $five -> multiply ( $oneQuarter ); // Prints: \"1.25\" 10 // The asDecimal() method is called on $oneQuarter 11 12 echo $oneQuarter -> multiply ( $five ); // Prints: \"5/4\" 13 // Calls getValue() on $five and instantiates a new ImmutableFraction divide(int|float|numeric|NumberInterface $num, int $scale = null): self This divides the argument from the Value using the ArithmeticProvider (which uses the BCMath library internally) and returns the newly calculated Value. The $scale argument tells the Value how many decimals of accuracy you want in your division (if that is relevant to the division), and defaults to the scale of the calling object if null. The default scale of a Value, if you do not set it during instantiation, is 10. When an object that implements DecimalInterface and another that implements FractionInterface are divided, the one that is provided as an argument is coerced into the type of original object. For example: 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $five = new ImmutableNumber ( 5 ); 7 $oneQuarter = new ImmutableFraction ( 1 , 4 ); 8 9 echo $five -> divide ( $oneQuarter ); // Prints: \"20\" 10 // The asDecimal() method is called on $oneQuarter 11 12 echo $oneQuarter -> divide ( $five ); // Prints: \"1/20\" 13 // Calls getValue() on $five and instantiates a new ImmutableFraction pow(int|float|numeric|NumberInterface $num): self This raises the Value to the power of $num, and will work even if $num has a decimal component. NOTE: This method will only return Real numbers as Values, as Complex numbers are not currently supported. When an object that implements DecimalInterface and another that implements FractionInterface are raised to a power, the one that is provided as an argument is coerced into the type of original object. For example: 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $five = new ImmutableNumber ( 5 ); 7 $oneQuarter = new ImmutableFraction ( 1 , 4 ); 8 9 echo $five -> pow ( $oneQuarter ); // Prints: \"1.4953487812\" 10 // The asDecimal() method is called on $oneQuarter 11 // Because $scale was not supplied to the constructor, $scale is 10 12 13 echo $oneQuarter -> pow ( $five ); // Prints: \"1/1024\" 14 // Calls getValue() on $five and instantiates a new ImmutableFraction sqrt(): self This takes the square root of the current object. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $five = new ImmutableNumber ( 5 ); 7 $oneQuarter = new ImmutableFraction ( 1 , 4 ); 8 9 echo $five -> sqrt (); // Prints: \"2.2360679775\" 10 // Because $scale was not supplied to the constructor, $scale is 10 11 12 echo $oneQuarter -> sqrt (); // Prints: \"1/2\" Working with DecimalInterface Additional arithmetic can be performed on objects that implement the DecimalInterface , and the rules for using arithmetic methods are the same as with NumberInterface methods: you can put any value that is valid for an ImmutableNumber constructor in, or you can put in any instance of an object that implements DecimalInterface itself. factorial(): self This takes the factorial of the current Value, however the Value must be a whole number. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 5 $five = new ImmutableNumber ( 5 ); 6 7 echo $five -> factorial (); // Prints: \"120\" doubleFactorial(): self, semiFactorial(): self This takes the double factorial (x!!) of the current Value. Note: If you are not familiar with this operation, it is NOT the same as taking the factorial twice: (x!)!. Instead it is like taking a factorial where you decrease the number by two instead of one: 10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 10!! = 10 * 8 * 6 * 4 * 2 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 5 $five = new ImmutableNumber ( 5 ); 6 7 echo $five -> doubleFactorial (); // Prints: \"15\" ln(int $scale = 10, $round = true): self This takes the natural log of the current Value, accurate to $scale decimal places. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 5 $five = new ImmutableNumber ( 5 ); 6 7 echo $five -> ln ( 11 ); // Prints: \"1.60943791243\" log10(int $scale = 10, $round = true): self This takes the log base10 of the current Value, accurate to $scale decimal places. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 5 $five = new ImmutableNumber ( 5 ); 6 7 echo $five -> log10 ( 11 ); // Prints: \"0.69897000434\" Working With ArithmeticProvider Directly The ArithmeticProvider is a wrapper for the BCMath library, and it is ultimately what performs most operations inside the objects that implement NumberInterface , DecimalInterface , FractionInterface , and CoordinateInterface . All of its methods are static, and can be accessed without instantiating the class. All arguments to this provider must be strings which only contain numeric values. add(string $number1, string $number2): string Calls bcadd($number1, $number2) with a scale setting of 100. subtract(string $left, string $right): string Calls bcsub($left, $right) with a scale setting of 100. multiply(string $number1, string $number2): string Calls bcmul($number1, $number2) with a scale setting of 100. divide(string $numerator, string $denominator, int $scale = 100): string Calls bcdiv($numerator, $denominator, $scale) . pow(string $base, string $exponent): string Calls bcpow($base, $exponent) with a scale of 100. Note: Unlike the pow() method on NumberInterface objects, the exponent must be a whole number. squareRoot(string $number, int $scale = 100): string Calls bcsqrt($number, $scale) . modulo(string $number, string $modulo): string Calls bcmod($number, $modulo) . Note: Unlike the continuousModulo() method on DecimalInterface objects, the modulus must be a whole number. compare(string $left, string $right, int $scale = 100): int Calls bccomp($left, $right, $scale) . Its output format is identical to the compare() helper method on NumberInterface objects. powmod(string left, string $right, string $modulus, int $scale = 100): string Calls bcpowmod($left, $right, $modulus, $scale) . factorial(string $number): string Calls bcmul() repeatedly to return the factorial. Note: The factorial() method on DecimalInterface objects does not use this method, and instead uses gmp_fact() if the method is available, and makes repeated calls to multiply() if it is not.","title":"Working With `NumberInterface`"},{"location":"arithmetic/#working-with-numberinterface","text":"Arithmetic can be performed on any class that implements the NumberInterface , and the rules for using arithmetic methods are consistent and straight-forward: you can put any value that is valid for an ImmutableNumber constructor in, or you can put in any instance of an object that implements NumberInterface itself. You Might Not Expect If two objects which have different calculation modes are used in an arithmetic operation, the calculation mode of the object which makes the function call is used, and the calculation mode of the object supplied as an argument is ignored. Additionally, the object returned will be of the same class as the object making the function call if that is possible. This means that fractions will be converted to decimals when they are the argument for a decimal function call, or visa versa. If the result must be represented in a particular way, such as with complex numbers, the returned value will be the immutable version of the class that can respresent the result. This means adding two classes that implement DecimalInterface can return a class that implements ComplexNumberInterface if one is an imaginary number, and one is a real number. The following arithmetic methods are available.","title":"Working With NumberInterface"},{"location":"arithmetic/#working-with-decimalinterface","text":"Additional arithmetic can be performed on objects that implement the DecimalInterface , and the rules for using arithmetic methods are the same as with NumberInterface methods: you can put any value that is valid for an ImmutableNumber constructor in, or you can put in any instance of an object that implements DecimalInterface itself.","title":"Working with DecimalInterface"},{"location":"arithmetic/#working-with-arithmeticprovider-directly","text":"The ArithmeticProvider is a wrapper for the BCMath library, and it is ultimately what performs most operations inside the objects that implement NumberInterface , DecimalInterface , FractionInterface , and CoordinateInterface . All of its methods are static, and can be accessed without instantiating the class. All arguments to this provider must be strings which only contain numeric values.","title":"Working With ArithmeticProvider Directly"},{"location":"arithmetic/complex/","text":"","title":"Complex Numbers"},{"location":"arithmetic/matrices/","text":"","title":"Matrices"},{"location":"arithmetic/simple/","text":"This page details the arithmetic operations available for classes which implement SimpleNumberInterface and that use ArithmeticSimpleTrait . Available Modes The ArithmeticSimpleTrait supports the modes: Selectable::CALC_MODE_PRECISION Selectable::CALC_MODE_NATIVE See Also For more detail on calculation modes, see the Getting Started > Calculation Modes page. Available Methods The following methods are available for classes that implement SimpleNumberInterface and that use ArithmeticSimpleTrait . Return Value Depends On Context While all return values will implement NumberInterface , the exact class returned depends on both what type is provided as the $num , and on the type of calling class. In general, the class that best fits the data of the result is returned, with preference given to the type of the calling class. See the examples below. Mixed Argument Limitations The arguments are listed in this documentation as mixed . In fact, the valid input types are: An integer A float A string that contains only a single number in base-10 A string that contains only a single number in base-10 with the i character at the end, denoting an imaginary value A string that contains two base-10 numbers separated by a division bar / A string that contains two base-10 numbers separated by a + or - , with the number on the right having the i character after the value An object that implements NumberInterface If the provided $value matches none of these, an exception of type Samsara\\Exceptions\\UsageError\\IntegrityConstraint is thrown. add(mixed $num): NumberInterface $num Accepts a mixed value that is limited to the formats detailed in the Available Methods section. returns Returns an object of the same class as the calling class if the resulting value can be represented with a SimpleNumberInterface . Returns an object of the ImmutableComplexNumber class if the resulting value has both a real and imaginary component. This function adds the current value with $num and returns the result. Examples: Add Decimal + Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $balance = new ImmutableDecimal ( '100' ); 6 $deposit = new ImmutableDecimal ( '50' ); 7 8 $balance = $balance -> add ( $deposit ); 9 10 echo \"Balance: \" . $balance ; 11 // Prints: 'Balance: 150' Decimal + Fraction 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $pizzas = new ImmutableDecimal ( '3' ); 7 $extraSlices = new ImmutableFraction ( '3' , '8' ); 8 9 $pizzas = $pizzas -> add ( $extraSlices ); 10 11 echo \"I have \" . $pizzas . \" pizzas\" ; 12 // Prints: 'I have 3.375 pizzas' Fraction + Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $leftOvers = new ImmutableFraction ( '3' , '8' ); 7 $newOrder = new ImmutableDecimal ( '3' ); 8 9 $pizzas = $leftOvers -> add ( $newOrder ); 10 11 echo \"I have \" . $pizzas -> getNumerator () . \" slices (\" . $pizzas . \" pizzas)\" ; 12 // Prints: 'I have 27 slices (27/8 pizzas)' Decimal + Complex 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableComplexNumber ; 5 6 // Four volts being added to the circuit 7 $newVoltage = new ImmutableDecimal ( '4' ); 8 // Six volts in the circuit originally 9 $oldVoltage = new ImmutableDecimal ( '6' ); 10 // Twenty amps in the circuit originally 11 $oldCurrent = new ImmutableDecimal ( '20i' ); 12 $circuitState = new ImmutableComplexNumber ( $oldVoltage , $oldCurrent ); 13 14 $newCircuitState = $newVoltage -> add ( $circuitState ); 15 16 echo 'Circuit State: ' . $newCircuitState ; 17 // Prints: 'Circuit State: 10+20i' 18 19 // Addition is commutative even for complex numbers 20 $newCircuitState = $circuitState -> add ( $newVoltage ); 21 22 echo 'Circuit State: ' . $newCircuitState ; 23 // Prints: 'Circuit State: 10+20i' subtract(mixed $num): NumberInterface $num Accepts a mixed value that is limited to the formats detailed in the Available Methods section. returns Returns an object of the same class as the calling class if the resulting value can be represented with a SimpleNumberInterface . Returns an object of the ImmutableComplexNumber class if the resulting value has both a real and imaginary component. This function subtracts $num from the current value and returns the result. Examples: Subtract Decimal - Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $balance = new ImmutableDecimal ( '100' ); 6 $debit = new ImmutableDecimal ( '50' ); 7 8 $balance = $balance -> subtract ( $debit ); 9 10 echo \"Balance: \" . $balance ; 11 // Prints: 'Balance: 50' Decimal - Fraction 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $pizzas = new ImmutableDecimal ( '3' ); 7 $eatenByFriends = new ImmutableFraction ( '3' , '8' ); 8 9 $pizzas = $pizzas -> subtract ( $eatenByFriends ); 10 11 echo \"I have \" . $pizzas . \" pizzas\" ; 12 // Prints: 'I have 2.625 pizzas' Fraction - Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $leftOvers = new ImmutableFraction ( '25' , '8' ); 7 $eatenByFriends = new ImmutableDecimal ( '2' ); 8 9 $pizzas = $leftOvers -> subtract ( $eatenByFriends ); 10 11 echo \"I have \" . $pizzas -> getNumerator () . \" slices (\" . $pizzas . \" pizzas)\" ; 12 // Prints: 'I have 9 slices (9/8 pizzas)' Decimal - Complex 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableComplexNumber ; 5 6 // Four volts being removed from the circuit 7 $newVoltage = new ImmutableDecimal ( '4' ); 8 // Six volts in the circuit originally 9 $oldVoltage = new ImmutableDecimal ( '6' ); 10 // Twenty amps in the circuit originally 11 $oldCurrent = new ImmutableDecimal ( '20i' ); 12 $circuitState = new ImmutableComplexNumber ( $oldVoltage , $oldCurrent ); 13 14 $newCircuitState = $newVoltage -> subtract ( $circuitState ); 15 16 echo 'Circuit State: ' . $newCircuitState ; 17 // Prints: 'Circuit State: -2-20i' 18 19 // Subtraction is not commutative 20 $newCircuitState = $circuitState -> subtract ( $newVoltage ); 21 22 echo 'Circuit State: ' . $newCircuitState ; 23 // Prints: 'Circuit State: 2+20i' multiply(mixed $num): NumberInterface $num Accepts a mixed value that is limited to the formats detailed in the Available Methods section. returns Returns an object of the same class as the calling class if the resulting value can be represented with a SimpleNumberInterface . Returns an object of the ImmutableComplexNumber class if the resulting value has both a real and imaginary component. This function multiplies $num with the current value and returns the result. Examples: Multiply Decimal X Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $balance = new ImmutableDecimal ( '100' ); 6 $returnRate = new ImmutableDecimal ( '1.05' ); 7 8 $balance = $balance -> multiply ( $returnRate ); 9 10 echo \"Balance: \" . $balance ; 11 // Prints: 'Balance: 105' Decimal X Fraction 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $friends = new ImmutableDecimal ( '3' ); 7 $slicesPerPerson = new ImmutableFraction ( '3' , '8' ); 8 9 $pizzas = $friends -> multiply ( $slicesPerPerson ); 10 11 echo \"I need \" . $pizzas . \" pizzas\" ; 12 // Prints: 'I have 3.125 pizzas' Fraction X Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $friends = new ImmutableDecimal ( '3' ); 7 $slicesPerPerson = new ImmutableFraction ( '3' , '8' ); 8 9 $pizzas = $friends -> multiply ( $slicesPerPerson ); 10 11 echo \"I need \" . $pizzas -> getNumerator () . \" slices (\" . $pizzas . \" pizzas)\" ; 12 // Prints: 'I need 9 slices (9/8 pizzas)' Decimal X Complex 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableComplexNumber ; 5 6 // Four circuits 7 $totalCircuits = new ImmutableDecimal ( '4' ); 8 // Six volts in each circuit 9 $oldVoltage = new ImmutableDecimal ( '6' ); 10 // Twenty amps in each circuit originally 11 $oldCurrent = new ImmutableDecimal ( '20i' ); 12 $circuitState = new ImmutableComplexNumber ( $oldVoltage , $oldCurrent ); 13 14 $newCircuitState = $totalCircuits -> multiply ( $circuitState ); 15 16 echo 'Circuit State: ' . $newCircuitState ; 17 // Prints: 'Circuit State: 24+80i' 18 19 // Multiplication is commutative 20 $newCircuitState = $circuitState -> multiply ( $totalCircuits ); 21 22 echo 'Circuit State: ' . $newCircuitState ; 23 // Prints: 'Circuit State: 24+80i' divide(mixed $num, ?int $scale = null): NumberInterface $num Accepts a mixed value that is limited to the formats detailed in the Available Methods section. returns Returns an object of the same class as the calling class if the resulting value can be represented with a SimpleNumberInterface . Returns an object of the ImmutableComplexNumber class if the resulting value has both a real and imaginary component. This function divides $num with the current value and returns the result. Automatic Scale If no scale setting is provided for this operation, the scale of both numbers is compared and the larger scale is used. The returned value has this programmatically determined scale, which can be greater than, but not less than, the scale of the calling object. Examples: Divide Decimal / Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $assets = new ImmutableDecimal ( '100' ); 6 $shares = new ImmutableDecimal ( '50' ); 7 8 $price = $assets -> divide ( $shares ); 9 10 echo \"Price: \" . $price ; 11 // Prints: 'Price: 2' Decimal / Fraction 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $pizzas = new ImmutableDecimal ( '4' ); 7 $slicesPerPerson = new ImmutableFraction ( '3' , '8' ); 8 9 $friends = $pizzas -> divide ( $slicesPerPerson ); 10 11 echo \"I have enough pizzas for \" . $friends . \" friends\" ; 12 // Prints: 'I have enough pizzas for 10.6666666666 friends' Fraction / Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $pizzaSlices = new ImmutableDecimal ( '3' ); 7 $slicesPerPerson = new ImmutableDecimal ( '3' ); 8 $friends = new ImmutableDecimal ( '6' ); 9 $pizzaGoal = new ImmutableFraction ( $slicesPerPerson , $friends ); 10 11 $pizzaGoal = $pizzaGoal -> divide ( $pizzaSlices ); 12 13 echo \"I have \" . $pizzaGoal . \" of the pizza needed to feed everyone\" ; 14 // Prints: 'I have 1/6 of the pizza needed to feed everyone' Decimal / Complex 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableComplexNumber ; 5 6 // Four circuits 7 $totalCircuits = new ImmutableDecimal ( '4' ); 8 // Six volts in each circuit 9 $oldVoltage = new ImmutableDecimal ( '6' ); 10 // Twenty amps in each circuit originally 11 $oldCurrent = new ImmutableDecimal ( '20i' ); 12 $circuitState = new ImmutableComplexNumber ( $oldVoltage , $oldCurrent ); 13 14 $newCircuitState = $totalCircuits -> divide ( $circuitState ); 15 16 echo 'Circuit State: ' . $newCircuitState ; 17 // Prints: 'Circuit State: 0.0550458715-0.1834862385i' 18 19 // Multiplication is commutative 20 $newCircuitState = $circuitState -> divide ( $totalCircuits ); 21 22 echo 'Circuit State: ' . $newCircuitState ; 23 // Prints: 'Circuit State: 1.5+5i' pow(mixed $num): NumberInterface $num Accepts a mixed value that is limited to the formats detailed in the Available Methods section. returns Returns an object of the same class as the calling class if the resulting value can be represented with a SimpleNumberInterface . Returns an object of the ImmutableComplexNumber class if the resulting value has both a real and imaginary component. This function raises the current value to the power of $num and returns the result. Examples: Divide Decimal ^ Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $assets = new ImmutableDecimal ( '100' ); 6 $growthRate = new ImmutableDecimal ( '1.05' ); 7 8 $value = $assets -> pow ( $growthRate ); 9 10 echo \"Value: \" . $value ; 11 // Prints: 'Value: 125.8925411794' Decimal ^ Fraction 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $pizzas = new ImmutableDecimal ( '4' ); 7 $slicesPerPerson = new ImmutableFraction ( '3' , '8' ); 8 9 $friends = $pizzas -> divide ( $slicesPerPerson ); 10 11 echo \"I have enough pizzas for \" . $friends . \" friends\" ; 12 // Prints: 'I have enough pizzas for 10.6666666666 friends' Fraction ^ Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $pizzaSlices = new ImmutableDecimal ( '3' ); 7 $slicesPerPerson = new ImmutableDecimal ( '3' ); 8 $friends = new ImmutableDecimal ( '6' ); 9 $pizzaGoal = new ImmutableFraction ( $slicesPerPerson , $friends ); 10 11 $pizzaGoal = $pizzaGoal -> divide ( $pizzaSlices ); 12 13 echo \"I have \" . $pizzaGoal . \" of the pizza needed to feed everyone\" ; 14 // Prints: 'I have 1/6 of the pizza needed to feed everyone' Decimal ^ Complex 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableComplexNumber ; 5 6 // Four circuits 7 $totalCircuits = new ImmutableDecimal ( '4' ); 8 // Six volts in each circuit 9 $oldVoltage = new ImmutableDecimal ( '6' ); 10 // Twenty amps in each circuit originally 11 $oldCurrent = new ImmutableDecimal ( '20i' ); 12 $circuitState = new ImmutableComplexNumber ( $oldVoltage , $oldCurrent ); 13 14 $newCircuitState = $totalCircuits -> divide ( $circuitState ); 15 16 echo 'Circuit State: ' . $newCircuitState ; 17 // Prints: 'Circuit State: 0.0550458715-0.1834862385i' 18 19 // Multiplication is commutative 20 $newCircuitState = $circuitState -> divide ( $totalCircuits ); 21 22 echo 'Circuit State: ' . $newCircuitState ; 23 // Prints: 'Circuit State: 1.5+5i'","title":"Simple Numbers"},{"location":"arithmetic/simple/#available-modes","text":"The ArithmeticSimpleTrait supports the modes: Selectable::CALC_MODE_PRECISION Selectable::CALC_MODE_NATIVE See Also For more detail on calculation modes, see the Getting Started > Calculation Modes page.","title":"Available Modes"},{"location":"arithmetic/simple/#available-methods","text":"The following methods are available for classes that implement SimpleNumberInterface and that use ArithmeticSimpleTrait . Return Value Depends On Context While all return values will implement NumberInterface , the exact class returned depends on both what type is provided as the $num , and on the type of calling class. In general, the class that best fits the data of the result is returned, with preference given to the type of the calling class. See the examples below. Mixed Argument Limitations The arguments are listed in this documentation as mixed . In fact, the valid input types are: An integer A float A string that contains only a single number in base-10 A string that contains only a single number in base-10 with the i character at the end, denoting an imaginary value A string that contains two base-10 numbers separated by a division bar / A string that contains two base-10 numbers separated by a + or - , with the number on the right having the i character after the value An object that implements NumberInterface If the provided $value matches none of these, an exception of type Samsara\\Exceptions\\UsageError\\IntegrityConstraint is thrown. add(mixed $num): NumberInterface $num Accepts a mixed value that is limited to the formats detailed in the Available Methods section. returns Returns an object of the same class as the calling class if the resulting value can be represented with a SimpleNumberInterface . Returns an object of the ImmutableComplexNumber class if the resulting value has both a real and imaginary component. This function adds the current value with $num and returns the result. Examples: Add Decimal + Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $balance = new ImmutableDecimal ( '100' ); 6 $deposit = new ImmutableDecimal ( '50' ); 7 8 $balance = $balance -> add ( $deposit ); 9 10 echo \"Balance: \" . $balance ; 11 // Prints: 'Balance: 150' Decimal + Fraction 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $pizzas = new ImmutableDecimal ( '3' ); 7 $extraSlices = new ImmutableFraction ( '3' , '8' ); 8 9 $pizzas = $pizzas -> add ( $extraSlices ); 10 11 echo \"I have \" . $pizzas . \" pizzas\" ; 12 // Prints: 'I have 3.375 pizzas' Fraction + Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $leftOvers = new ImmutableFraction ( '3' , '8' ); 7 $newOrder = new ImmutableDecimal ( '3' ); 8 9 $pizzas = $leftOvers -> add ( $newOrder ); 10 11 echo \"I have \" . $pizzas -> getNumerator () . \" slices (\" . $pizzas . \" pizzas)\" ; 12 // Prints: 'I have 27 slices (27/8 pizzas)' Decimal + Complex 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableComplexNumber ; 5 6 // Four volts being added to the circuit 7 $newVoltage = new ImmutableDecimal ( '4' ); 8 // Six volts in the circuit originally 9 $oldVoltage = new ImmutableDecimal ( '6' ); 10 // Twenty amps in the circuit originally 11 $oldCurrent = new ImmutableDecimal ( '20i' ); 12 $circuitState = new ImmutableComplexNumber ( $oldVoltage , $oldCurrent ); 13 14 $newCircuitState = $newVoltage -> add ( $circuitState ); 15 16 echo 'Circuit State: ' . $newCircuitState ; 17 // Prints: 'Circuit State: 10+20i' 18 19 // Addition is commutative even for complex numbers 20 $newCircuitState = $circuitState -> add ( $newVoltage ); 21 22 echo 'Circuit State: ' . $newCircuitState ; 23 // Prints: 'Circuit State: 10+20i' subtract(mixed $num): NumberInterface $num Accepts a mixed value that is limited to the formats detailed in the Available Methods section. returns Returns an object of the same class as the calling class if the resulting value can be represented with a SimpleNumberInterface . Returns an object of the ImmutableComplexNumber class if the resulting value has both a real and imaginary component. This function subtracts $num from the current value and returns the result. Examples: Subtract Decimal - Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $balance = new ImmutableDecimal ( '100' ); 6 $debit = new ImmutableDecimal ( '50' ); 7 8 $balance = $balance -> subtract ( $debit ); 9 10 echo \"Balance: \" . $balance ; 11 // Prints: 'Balance: 50' Decimal - Fraction 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $pizzas = new ImmutableDecimal ( '3' ); 7 $eatenByFriends = new ImmutableFraction ( '3' , '8' ); 8 9 $pizzas = $pizzas -> subtract ( $eatenByFriends ); 10 11 echo \"I have \" . $pizzas . \" pizzas\" ; 12 // Prints: 'I have 2.625 pizzas' Fraction - Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $leftOvers = new ImmutableFraction ( '25' , '8' ); 7 $eatenByFriends = new ImmutableDecimal ( '2' ); 8 9 $pizzas = $leftOvers -> subtract ( $eatenByFriends ); 10 11 echo \"I have \" . $pizzas -> getNumerator () . \" slices (\" . $pizzas . \" pizzas)\" ; 12 // Prints: 'I have 9 slices (9/8 pizzas)' Decimal - Complex 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableComplexNumber ; 5 6 // Four volts being removed from the circuit 7 $newVoltage = new ImmutableDecimal ( '4' ); 8 // Six volts in the circuit originally 9 $oldVoltage = new ImmutableDecimal ( '6' ); 10 // Twenty amps in the circuit originally 11 $oldCurrent = new ImmutableDecimal ( '20i' ); 12 $circuitState = new ImmutableComplexNumber ( $oldVoltage , $oldCurrent ); 13 14 $newCircuitState = $newVoltage -> subtract ( $circuitState ); 15 16 echo 'Circuit State: ' . $newCircuitState ; 17 // Prints: 'Circuit State: -2-20i' 18 19 // Subtraction is not commutative 20 $newCircuitState = $circuitState -> subtract ( $newVoltage ); 21 22 echo 'Circuit State: ' . $newCircuitState ; 23 // Prints: 'Circuit State: 2+20i' multiply(mixed $num): NumberInterface $num Accepts a mixed value that is limited to the formats detailed in the Available Methods section. returns Returns an object of the same class as the calling class if the resulting value can be represented with a SimpleNumberInterface . Returns an object of the ImmutableComplexNumber class if the resulting value has both a real and imaginary component. This function multiplies $num with the current value and returns the result. Examples: Multiply Decimal X Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $balance = new ImmutableDecimal ( '100' ); 6 $returnRate = new ImmutableDecimal ( '1.05' ); 7 8 $balance = $balance -> multiply ( $returnRate ); 9 10 echo \"Balance: \" . $balance ; 11 // Prints: 'Balance: 105' Decimal X Fraction 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $friends = new ImmutableDecimal ( '3' ); 7 $slicesPerPerson = new ImmutableFraction ( '3' , '8' ); 8 9 $pizzas = $friends -> multiply ( $slicesPerPerson ); 10 11 echo \"I need \" . $pizzas . \" pizzas\" ; 12 // Prints: 'I have 3.125 pizzas' Fraction X Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $friends = new ImmutableDecimal ( '3' ); 7 $slicesPerPerson = new ImmutableFraction ( '3' , '8' ); 8 9 $pizzas = $friends -> multiply ( $slicesPerPerson ); 10 11 echo \"I need \" . $pizzas -> getNumerator () . \" slices (\" . $pizzas . \" pizzas)\" ; 12 // Prints: 'I need 9 slices (9/8 pizzas)' Decimal X Complex 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableComplexNumber ; 5 6 // Four circuits 7 $totalCircuits = new ImmutableDecimal ( '4' ); 8 // Six volts in each circuit 9 $oldVoltage = new ImmutableDecimal ( '6' ); 10 // Twenty amps in each circuit originally 11 $oldCurrent = new ImmutableDecimal ( '20i' ); 12 $circuitState = new ImmutableComplexNumber ( $oldVoltage , $oldCurrent ); 13 14 $newCircuitState = $totalCircuits -> multiply ( $circuitState ); 15 16 echo 'Circuit State: ' . $newCircuitState ; 17 // Prints: 'Circuit State: 24+80i' 18 19 // Multiplication is commutative 20 $newCircuitState = $circuitState -> multiply ( $totalCircuits ); 21 22 echo 'Circuit State: ' . $newCircuitState ; 23 // Prints: 'Circuit State: 24+80i' divide(mixed $num, ?int $scale = null): NumberInterface $num Accepts a mixed value that is limited to the formats detailed in the Available Methods section. returns Returns an object of the same class as the calling class if the resulting value can be represented with a SimpleNumberInterface . Returns an object of the ImmutableComplexNumber class if the resulting value has both a real and imaginary component. This function divides $num with the current value and returns the result. Automatic Scale If no scale setting is provided for this operation, the scale of both numbers is compared and the larger scale is used. The returned value has this programmatically determined scale, which can be greater than, but not less than, the scale of the calling object. Examples: Divide Decimal / Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $assets = new ImmutableDecimal ( '100' ); 6 $shares = new ImmutableDecimal ( '50' ); 7 8 $price = $assets -> divide ( $shares ); 9 10 echo \"Price: \" . $price ; 11 // Prints: 'Price: 2' Decimal / Fraction 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $pizzas = new ImmutableDecimal ( '4' ); 7 $slicesPerPerson = new ImmutableFraction ( '3' , '8' ); 8 9 $friends = $pizzas -> divide ( $slicesPerPerson ); 10 11 echo \"I have enough pizzas for \" . $friends . \" friends\" ; 12 // Prints: 'I have enough pizzas for 10.6666666666 friends' Fraction / Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $pizzaSlices = new ImmutableDecimal ( '3' ); 7 $slicesPerPerson = new ImmutableDecimal ( '3' ); 8 $friends = new ImmutableDecimal ( '6' ); 9 $pizzaGoal = new ImmutableFraction ( $slicesPerPerson , $friends ); 10 11 $pizzaGoal = $pizzaGoal -> divide ( $pizzaSlices ); 12 13 echo \"I have \" . $pizzaGoal . \" of the pizza needed to feed everyone\" ; 14 // Prints: 'I have 1/6 of the pizza needed to feed everyone' Decimal / Complex 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableComplexNumber ; 5 6 // Four circuits 7 $totalCircuits = new ImmutableDecimal ( '4' ); 8 // Six volts in each circuit 9 $oldVoltage = new ImmutableDecimal ( '6' ); 10 // Twenty amps in each circuit originally 11 $oldCurrent = new ImmutableDecimal ( '20i' ); 12 $circuitState = new ImmutableComplexNumber ( $oldVoltage , $oldCurrent ); 13 14 $newCircuitState = $totalCircuits -> divide ( $circuitState ); 15 16 echo 'Circuit State: ' . $newCircuitState ; 17 // Prints: 'Circuit State: 0.0550458715-0.1834862385i' 18 19 // Multiplication is commutative 20 $newCircuitState = $circuitState -> divide ( $totalCircuits ); 21 22 echo 'Circuit State: ' . $newCircuitState ; 23 // Prints: 'Circuit State: 1.5+5i' pow(mixed $num): NumberInterface $num Accepts a mixed value that is limited to the formats detailed in the Available Methods section. returns Returns an object of the same class as the calling class if the resulting value can be represented with a SimpleNumberInterface . Returns an object of the ImmutableComplexNumber class if the resulting value has both a real and imaginary component. This function raises the current value to the power of $num and returns the result. Examples: Divide Decimal ^ Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $assets = new ImmutableDecimal ( '100' ); 6 $growthRate = new ImmutableDecimal ( '1.05' ); 7 8 $value = $assets -> pow ( $growthRate ); 9 10 echo \"Value: \" . $value ; 11 // Prints: 'Value: 125.8925411794' Decimal ^ Fraction 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $pizzas = new ImmutableDecimal ( '4' ); 7 $slicesPerPerson = new ImmutableFraction ( '3' , '8' ); 8 9 $friends = $pizzas -> divide ( $slicesPerPerson ); 10 11 echo \"I have enough pizzas for \" . $friends . \" friends\" ; 12 // Prints: 'I have enough pizzas for 10.6666666666 friends' Fraction ^ Decimal 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableFraction ; 5 6 $pizzaSlices = new ImmutableDecimal ( '3' ); 7 $slicesPerPerson = new ImmutableDecimal ( '3' ); 8 $friends = new ImmutableDecimal ( '6' ); 9 $pizzaGoal = new ImmutableFraction ( $slicesPerPerson , $friends ); 10 11 $pizzaGoal = $pizzaGoal -> divide ( $pizzaSlices ); 12 13 echo \"I have \" . $pizzaGoal . \" of the pizza needed to feed everyone\" ; 14 // Prints: 'I have 1/6 of the pizza needed to feed everyone' Decimal ^ Complex 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 use Samsara\\Fermat\\Values\\ImmutableComplexNumber ; 5 6 // Four circuits 7 $totalCircuits = new ImmutableDecimal ( '4' ); 8 // Six volts in each circuit 9 $oldVoltage = new ImmutableDecimal ( '6' ); 10 // Twenty amps in each circuit originally 11 $oldCurrent = new ImmutableDecimal ( '20i' ); 12 $circuitState = new ImmutableComplexNumber ( $oldVoltage , $oldCurrent ); 13 14 $newCircuitState = $totalCircuits -> divide ( $circuitState ); 15 16 echo 'Circuit State: ' . $newCircuitState ; 17 // Prints: 'Circuit State: 0.0550458715-0.1834862385i' 18 19 // Multiplication is commutative 20 $newCircuitState = $circuitState -> divide ( $totalCircuits ); 21 22 echo 'Circuit State: ' . $newCircuitState ; 23 // Prints: 'Circuit State: 1.5+5i'","title":"Available Methods"},{"location":"arithmetic/traits/","text":"","title":"Built In Traits"},{"location":"configuration/calculation-modes/","text":"Available Modes All modes which are defined exist as constants on the Selectable class. There are two modes currently available in Fermat. Scale Mode Selectable::CALC_MODE_PRECISION = 1 In this mode, the best available string math implementation is used when a mathematical operation is performed. By default these are the functions provided by the BCMath library, however a future scope of this project is to provide integration with ext-decimal . For Certain Operations, BCMath Is Ignored If the ext-gmp extension is present, it is used when both the input and output of an operation are guaranteed to be integers. This helps improve performance of operations which do not have a scale component. A non-exhaustive list of these situations includes: Using the factorial() method. Using the add() method on two integers. Using the multiply() method on two integers. Note that ext-gmp is never used for divide, as optimistic use of the extension would result in a large performance cost for non-exact division at a very small performance gain in the case of exact division. Native Mode Selectable::CALC_MODE_NATIVE = 2 In this mode, the native PHP math operators are used for calculation. The result is then converted to a string and stored according to the normal behavior of the class in question. Loss Of Scale The scale defined in the object is ignored when this mode is used. This will result in values which behave as math operations in PHP would natively, including issues such as overflow and underflow. Better Performance In Low Scale Situations As a trade-off for accepting more ambiguous scale in the result, using this mode will decrease the computation required for basic math operations, in some cases quite significantly. If you are absolutely certain that your math will not result in an overflow or underflow, and your application is not sensitive to loss of scale in float values, using this mode will reduce the cost of each mathematical operation. Expanding Native Types With the mode set to native, this library functions as simply an extension to integer and float types that enables representations of imaginary numbers, complex numbers, matrices, coordinates, and statistics. In this way, the library may be useful even if arbitrary scale is not necessary for your application. Controlling the Mode of Objects There are two main ways of controlling the mode used by your Fermat objects. The first is through the use of the default mode, and the second is with the use of the setMode() method. Default Mode All objects that extend the Number abstract class set their current mode to the default calculation mode returned by Numbers::getDefaultCalcMode() . This check is only done during instantiation, meaning that changing the default calculation mode using Numbers::setDefaultCalcMode() will only affect objects instantiated after this change is made. Interaction With Immutable Objects Because immutable objects create new instances for every mathematical operation performed, changing the default calculation mode in the middle of application execution will result in all previously created immutables utilizing the original mode for their first mathematical operation, and the new mode for every subsequent operation. If immutable objects are being used, the default mode should never be changed in the middle of application execution. Instead, set it to the desired value at the beginning of the application, or use the setMode() method after a new object is instantiated. See Also Further information on how to use default modes is available in the Numbers Factory Class documentation. Set Mode setMode(int $mode) This method is available on all classes that extend the Number abstract class. It sets the mode of the object it is called on to the mode provided. Use Only Defined Modes While setMode() will accept any integer, you should only ever use inputs that are defined as constants on the Selectable class to avoid unexpected behaviors. This Method Is Mutable For All Objects Because of the nature of what this method does, it is mutable for all objects, including any implementations of immutable objects.","title":"Calculation Modes"},{"location":"configuration/calculation-modes/#available-modes","text":"All modes which are defined exist as constants on the Selectable class. There are two modes currently available in Fermat.","title":"Available Modes"},{"location":"configuration/calculation-modes/#scale-mode","text":"","title":"Scale Mode"},{"location":"configuration/calculation-modes/#native-mode","text":"","title":"Native Mode"},{"location":"configuration/calculation-modes/#controlling-the-mode-of-objects","text":"There are two main ways of controlling the mode used by your Fermat objects. The first is through the use of the default mode, and the second is with the use of the setMode() method.","title":"Controlling the Mode of Objects"},{"location":"configuration/calculation-modes/#default-mode","text":"All objects that extend the Number abstract class set their current mode to the default calculation mode returned by Numbers::getDefaultCalcMode() . This check is only done during instantiation, meaning that changing the default calculation mode using Numbers::setDefaultCalcMode() will only affect objects instantiated after this change is made. Interaction With Immutable Objects Because immutable objects create new instances for every mathematical operation performed, changing the default calculation mode in the middle of application execution will result in all previously created immutables utilizing the original mode for their first mathematical operation, and the new mode for every subsequent operation. If immutable objects are being used, the default mode should never be changed in the middle of application execution. Instead, set it to the desired value at the beginning of the application, or use the setMode() method after a new object is instantiated. See Also Further information on how to use default modes is available in the Numbers Factory Class documentation.","title":"Default Mode"},{"location":"configuration/calculation-modes/#set-mode","text":"","title":"Set Mode"},{"location":"configuration/rounding-modes/","text":"Rounding Modes Rounding in Fermat is accomplished by making calls to the RoundingProvider . This provider accepts a DecimalInterface as its input, and provides the rounded value as a string. The rounding provider provides two broad types of rounding, deterministic and non-deterministic (or semi-deterministic). Rounding is Anything that Reduces Scale Many people think of rounding as selecting the closest integer to a given number, with some kind of rule for what to do when you are half-way between two integers. However, rounding broadly covers any action that reduces the scale or precision of a number. Going from more digits to fewer digits is rounding regardless of how it is done. This means that even operations like truncate() or floor() or ceil() are rounding. Since truncate is better handled by the Decimal object itself, due to its knowledge of the internal state of the object, that is not handled by the RoundingProvider . All other kinds of rounding offered in Fermat utilize the RoundingProvider however. For this reason it is designed to be as lightweight as possible while still accomplishing its task. The random provider has a private static property where it stores the mode to use while rounding. This property can be read and set using public static methods, but as it is a static property it affects all rounding operations after a mode is changed, even those you don't directly call. This is useful in most cases, since it allows you to set the rounding mode once at the beginning of your program and then utilize that rounding mode in every call that is made to the library. The default mode is RandomProvider::MODE_HALF_EVEN . This is also the fallback mode if you ask for a non-existent rounding mode. Rounding Mode Affects Many Operations Internally Rounding occurs frequently in Fermat, since many operations produce more digits than the scale setting of your objects. The trigonometry functions, logarithmic function, and exponential functions all make a call to the RoundingProvider before returning a result. This means that selecting a rounding mode will affect the results you get from functions such as tan() , sin() , exp() , and ln() . In most cases this is not an issue, and would even be preferred to keep your results consistent with the other effects of rounding within the library. However, some modes such as Stochastic may produce results that are more inconsistent with the expectations of your program. If you want to manually round an object once using a different mode, pass the mode as an argument to the round() method on your Decimal object instead of setting a new default more in the RoundingProvider . When done in this way, the provided mode will only be used for that one operation without affecting the default more for any other operations. See Also The exact signatures associated with the RandomProvider can be found in the Rounding Provider Reference Page Available Modes Rounding Is Base-10 Referenced As noted in other places, anything related to scale in this library is specific to base-10. While you can still round in other bases, the operations will be performed on the base-10 representation of the number instead of the base the Decimal object is in. Examples Assume Rounding to the Closest Integer In all of the examples given below, they are showing what the expected outputs would be if RoundingProvider::round($decimal, $places) was called with the example value for $decimal and 0 for $places . If a number with more digits were provided and a different value for $places was used, these rounding modes would all round towards a different target digit. The examples describe the behavior if the $places argument is omitted, since its default value is 0. But you could just as easily use any mode to round to the nearest tenth by passing 1 for the $places argument. Half Up This rounding mode rounds the number towards positive infinity when halfway between two values. Examples 1.5 Using the \"Half Up\" mode: 1.5 -> 2 -1.5 Using the \"Half Up\" mode: -1.5 -> -1 2.5 Using the \"Half Up\" mode: 2.5 -> 3 -2.5 Using the \"Half Up\" mode: -2.5 -> -2 Half Down This rounding mode rounds the number towards negative infinity when halfway between two values. Examples 1.5 Using the \"Half Down\" mode: 1.5 -> 1 -1.5 Using the \"Half Down\" mode: -1.5 -> -2 2.5 Using the \"Half Down\" mode: 2.5 -> 2 -2.5 Using the \"Half Down\" mode: -2.5 -> -3 Half Even This rounding mode rounds the number towards the nearest even number when halfway between two values. Examples 1.5 Using the \"Half Even\" mode: 1.5 -> 2 -1.5 Using the \"Half Even\" mode: -1.5 -> -2 2.5 Using the \"Half Even\" mode: 2.5 -> 2 -2.5 Using the \"Half Even\" mode: -2.5 -> -2 Half Odd This rounding mode rounds the number towards the nearest odd number when halfway between two values. Examples 1.5 Using the \"Half Odd\" mode: 1.5 -> 1 -1.5 Using the \"Half Odd\" mode: -1.5 -> -1 2.5 Using the \"Half Odd\" mode: 2.5 -> 3 -2.5 Using the \"Half Odd\" mode: -2.5 -> -3 Half Zero This rounding mode rounds the number towards zero when halfway between two values. Examples 1.5 Using the \"Half Zero\" mode: 1.5 -> 1 -1.5 Using the \"Half Zero\" mode: -1.5 -> -1 2.5 Using the \"Half Zero\" mode: 2.5 -> 2 -2.5 Using the \"Half Zero\" mode: -2.5 -> -2 Half Infinity This rounding mode rounds the number towards the nearest infinity (positive or negative) when halfway between two values. Examples 1.5 Using the \"Half Infinity\" mode: 1.5 -> 2 -1.5 Using the \"Half Infinity\" mode: -1.5 -> -2 2.5 Using the \"Half Infinity\" mode: 2.5 -> 3 -2.5 Using the \"Half Infinity\" mode: -2.5 -> -3 Ceil This rounding mode rounds the number towards positive infinity, even for values which are not halfway between. Examples 1.5 Using the \"Ceil\" mode: 1.5 -> 2 -1.5 Using the \"Ceil\" mode: -1.5 -> -1 2.2 Using the \"Ceil\" mode: 2.2 -> 3 -2.2 Using the \"Ceil\" mode: -2.2 -> -2 Floor This rounding mode rounds the number towards negative infinity, even for values which are not halfway between. Examples 1.5 Using the \"Floor\" mode: 1.5 -> 1 -1.5 Using the \"Floor\" mode: -1.5 -> -2 2.2 Using the \"Floor\" mode: 2.2 -> 2 -2.2 Using the \"Floor\" mode: -2.2 -> -3 Random This rounding mode rounds the number in a direction that is randomly chosen when halfway between two values. Examples 1.5 Using the \"Random\" mode: 1.5 -> 1 50% of the time 1.5 -> 2 50% of the time 1.7 Using the \"Random\" mode: 1.7 -> 2 100% of the time 2.2 Using the \"Random\" mode: 2.2 -> 2 100% of the time -2.5 Using the \"Random\" mode: -2.5 -> -2 50% of the time -2.5 -> -3 50% of the time Alternating This rounding mode rounds the number in a direction that alternates as more calls to round() are made when halfway between two values. Examples 1.5 Using the \"Alternating\" mode: 1.5 -> 2 on the first call 1.5 -> 1 on the second call 1.7 Using the \"Alternating\" mode: 1.7 -> 2 100% of the time 2.2 Using the \"Alternating\" mode: 2.2 -> 2 100% of the time -2.5 Using the \"Alternating\" mode: -2.5 -> -3 on the first call -2.5 -> -2 on the second call Stochastic This rounding mode rounds the number in both directions in proportion to how close it is to both values. This occurs regardless of whether the number is halfway between. Please see the examples below for clarification. Examples 1.5 Using the \"Stochastic\" mode: 1.5 -> 2 50% of the time 1.5 -> 1 50% of the time 1.7 Using the \"Stochastic\" mode: 1.7 -> 2 70% of the time 1.7 -> 1 30% of the time 2.2 Using the \"Stochastic\" mode: 2.2 -> 3 20% of the time 2.2 -> 2 80% of the time -2.5 Using the \"Stochastic\" mode: -2.5 -> -3 50% of the time -2.5 -> -2 50% of the time","title":"Rounding Modes"},{"location":"configuration/rounding-modes/#rounding-modes","text":"Rounding in Fermat is accomplished by making calls to the RoundingProvider . This provider accepts a DecimalInterface as its input, and provides the rounded value as a string. The rounding provider provides two broad types of rounding, deterministic and non-deterministic (or semi-deterministic). Rounding is Anything that Reduces Scale Many people think of rounding as selecting the closest integer to a given number, with some kind of rule for what to do when you are half-way between two integers. However, rounding broadly covers any action that reduces the scale or precision of a number. Going from more digits to fewer digits is rounding regardless of how it is done. This means that even operations like truncate() or floor() or ceil() are rounding. Since truncate is better handled by the Decimal object itself, due to its knowledge of the internal state of the object, that is not handled by the RoundingProvider . All other kinds of rounding offered in Fermat utilize the RoundingProvider however. For this reason it is designed to be as lightweight as possible while still accomplishing its task. The random provider has a private static property where it stores the mode to use while rounding. This property can be read and set using public static methods, but as it is a static property it affects all rounding operations after a mode is changed, even those you don't directly call. This is useful in most cases, since it allows you to set the rounding mode once at the beginning of your program and then utilize that rounding mode in every call that is made to the library. The default mode is RandomProvider::MODE_HALF_EVEN . This is also the fallback mode if you ask for a non-existent rounding mode. Rounding Mode Affects Many Operations Internally Rounding occurs frequently in Fermat, since many operations produce more digits than the scale setting of your objects. The trigonometry functions, logarithmic function, and exponential functions all make a call to the RoundingProvider before returning a result. This means that selecting a rounding mode will affect the results you get from functions such as tan() , sin() , exp() , and ln() . In most cases this is not an issue, and would even be preferred to keep your results consistent with the other effects of rounding within the library. However, some modes such as Stochastic may produce results that are more inconsistent with the expectations of your program. If you want to manually round an object once using a different mode, pass the mode as an argument to the round() method on your Decimal object instead of setting a new default more in the RoundingProvider . When done in this way, the provided mode will only be used for that one operation without affecting the default more for any other operations. See Also The exact signatures associated with the RandomProvider can be found in the Rounding Provider Reference Page","title":"Rounding Modes"},{"location":"configuration/rounding-modes/#available-modes","text":"Rounding Is Base-10 Referenced As noted in other places, anything related to scale in this library is specific to base-10. While you can still round in other bases, the operations will be performed on the base-10 representation of the number instead of the base the Decimal object is in. Examples Assume Rounding to the Closest Integer In all of the examples given below, they are showing what the expected outputs would be if RoundingProvider::round($decimal, $places) was called with the example value for $decimal and 0 for $places . If a number with more digits were provided and a different value for $places was used, these rounding modes would all round towards a different target digit. The examples describe the behavior if the $places argument is omitted, since its default value is 0. But you could just as easily use any mode to round to the nearest tenth by passing 1 for the $places argument.","title":"Available Modes"},{"location":"expressions/","text":"","title":"Index"},{"location":"getting-started/comparing/","text":"Limitations of Native Inequality Operators For values that cannot be represented as an integer or float accurately, using the native inequality operators will result in erroneous results. In some cases, this might also result in underflow and overflow of the native types. Because of this, all comparisons, including equality comparisons which would normally be == or === in PHP, should be performed using the comparison methods provided on all objects which extend the Number abstract class. Complex Number Limitations The ComplexNumber abstract class, and all of its child classes, only implement the isEqual() method. This is because inequality is poorly defined for complex numbers. There is no sensible and consistent way to evaluate the statement (2+2i) >= (1+1i) , even though one might expect this to return true. The issue is that the inequality methods must return a boolean , and even in the cases where it might be argued that either the true case or false case is well-defined, the opposite case is always ambiguous under any definition of inequality for complex numbers. This makes the return values of such statements meaningless in the context of complex numbers. You Might Not Expect The isEqual() method on the ComplexNumber class and all of its children checks first whether or not the compared value is also a complex number. This means that the following comparison will return false , even though one might expect it to return true : 2+0i == 2 This ambiguity is unlikely to occur in normal usage of the Fermat library, since all math operations which can lead to a zero value for either the real part or the imaginary part will return an instance of ImmutableDecimal instead. The only way to see this behavior is to manually instantiate a complex number with a zero value for one of its parts. Equality There are two types of equality that can be compared using this library: equality of value, and equality of representation. In virtually all cases equality of value is what is intended, and this is accomplished with the isEqual() method. Equality of representation is accomplished with the equals() method, and only returns true if the value being compared has the same value and is an instance of the same class. isEqual(mixed $value) Any $value which is a valid input for Numbers::makeOrDont() can be provided here. Returns true if the values are the same, false otherwise. Scale Only Affects the Result for Significant Figures Two objects with different scale settings will only return false if one of them has significant figures beyond the scale limit of the other. For instance, Numbers::makeOne(5) and Numbers::makeOne(10) will return true when compared using this method, even though internally they would be represented by 1.00000 and 1.0000000000 . equals(object $value) Returns true if the $value is an instance of the same class and it has the same value, false otherwise. Implemented As Part of the Hashable Interface As part of integration with the ext-ds extension, this method has been implemented to satisfy the Hashable interface. This is mainly so that objects which are instances of the Number abstract class can be used as array keys. Inequality These methods are only available on numbers that implement the SimpleNumberInterface . They are safe to use between different types of classes that implement the SimpleNumberInterface , and will perform the necessary conversions to return an answer. isGreaterThan(mixed $value); isLessThan(mixed $value) isGreaterThanOrEqualTo(mixed $value) isLessThanOrEqualTo(mixed $value) Any $value which is a valid input for Numbers::makeOrDont() can be provided to these methods. They are analogous to the corresponding comparison operators in PHP, but are safe to use with the arbitrary scale values found in this library. Sorting Comparison <=> The spaceship operator <=> , which returns 1 , 0 , or -1 to provide sorting order information, would result in many of the same issues described for the isEqual() method. This is handled internally by the BCMath extension. compare(mixed $value) Any $value which is a valid input for Numbers::makeOrDont() can be provided to this method. Returns 1 if the current object is greater than $value , 0 if they are equal, and -1 if the current object is less than $value . Internally Referenced By Other Comparisons All other comparison methods reference this method. This ensures that any return values of all possible comparison methods will remain consistent with each other no matter what implementation of compare() is used. The only exception is ComplexNumber , which implements isEqual() but not compare() .","title":"Comparing Values"},{"location":"getting-started/comparing/#limitations-of-native-inequality-operators","text":"For values that cannot be represented as an integer or float accurately, using the native inequality operators will result in erroneous results. In some cases, this might also result in underflow and overflow of the native types. Because of this, all comparisons, including equality comparisons which would normally be == or === in PHP, should be performed using the comparison methods provided on all objects which extend the Number abstract class. Complex Number Limitations The ComplexNumber abstract class, and all of its child classes, only implement the isEqual() method. This is because inequality is poorly defined for complex numbers. There is no sensible and consistent way to evaluate the statement (2+2i) >= (1+1i) , even though one might expect this to return true. The issue is that the inequality methods must return a boolean , and even in the cases where it might be argued that either the true case or false case is well-defined, the opposite case is always ambiguous under any definition of inequality for complex numbers. This makes the return values of such statements meaningless in the context of complex numbers. You Might Not Expect The isEqual() method on the ComplexNumber class and all of its children checks first whether or not the compared value is also a complex number. This means that the following comparison will return false , even though one might expect it to return true : 2+0i == 2 This ambiguity is unlikely to occur in normal usage of the Fermat library, since all math operations which can lead to a zero value for either the real part or the imaginary part will return an instance of ImmutableDecimal instead. The only way to see this behavior is to manually instantiate a complex number with a zero value for one of its parts.","title":"Limitations of Native Inequality Operators"},{"location":"getting-started/comparing/#equality","text":"There are two types of equality that can be compared using this library: equality of value, and equality of representation. In virtually all cases equality of value is what is intended, and this is accomplished with the isEqual() method. Equality of representation is accomplished with the equals() method, and only returns true if the value being compared has the same value and is an instance of the same class.","title":"Equality"},{"location":"getting-started/comparing/#inequality","text":"These methods are only available on numbers that implement the SimpleNumberInterface . They are safe to use between different types of classes that implement the SimpleNumberInterface , and will perform the necessary conversions to return an answer.","title":"Inequality"},{"location":"getting-started/comparing/#sorting-comparison","text":"The spaceship operator <=> , which returns 1 , 0 , or -1 to provide sorting order information, would result in many of the same issues described for the isEqual() method. This is handled internally by the BCMath extension.","title":"Sorting Comparison &lt;=&gt;"},{"location":"getting-started/concepts/","text":"Concepts Fermat has some vocabulary and concepts that are unique to this library, and they are documented here. Providers A provider in Fermat is a static class which provides a specific functionality to the entire library. It makes this interface available using static methods and wherever possible is permissive about the values it accepts as arguments. What is meant by that is you can, in most cases, pass an implementation of NumberInterface, a numeric string, an int, or a float. Please note that there are exceptions to this general principle and consult the method documentation. The current list of providers, documented in more detail in the section for Providers, is: ArithmeticProvider ConstantProvider PolyfillProvider SequenceProvider SeriesProvider StatsProvider TrigonometryProvider See Also The Providers included in Fermat are documented in more detail under \"Reference\". Types A type in Fermat is an implementation of a class of number or math concept. These are (with the exception of Tuple and NumberCollection ) abstract classes that are meant to be extended into classes which can be instantiated. This is mostly to provide both mutable and immutable versions of each type. A Tuple is meant to be inherently immutable, while a NumberCollection is mean to inherently mutable. The current list of types is: ComplexNumber Coordinate Decimal Expression Fraction Matrix NumberCollection Tuple See Also The Types included in Fermat are documented in more detail under \"Types & Values\". Values A value in Fermat is a usable implementation that can be directly worked with to perform math operations of some kind. These represent concrete concepts or types of values that have specific intended behavior and usage. The current list of values is: Algebra PolynomialFunction Geometry CoordinateSystems CartesianCoordinate CylindricalCoordinate PolarCoordinate SphericalCoordinate ImmutableComplexNumber ImmutableDecimal ImmutableFraction ImmutableMatrix MutableComplexNumber MutableDecimal MutableFraction MutableMatrix See Also The Values included in Fermat are documented in more detail under \"Types & Values\". Scale The basis of this library is being able to provide answers at any requested scale. Scale, as used in this library, is the number of digits after the decimal point which are returned. This is in contrast to significant figures or precision , which represent the numbers of digits returned after the decimal point after trimming all the leading zeros. There are two main reasons for providing scale as the main way of controlling how precise the answer is: It ensures that the string size of values with the same scale are comparable. It is far easier to implement some of the converging series calculations within this library, such as those for trigonometry functions, if scale is used instead of precision. In actual fact, significant figures have much less meaning in the context of a Taylor series or MacLauren series. If precision was used, the library would have to make more assumptions about the intent of calling code, and those assumptions would be less transparent. Scale Does Not Increase With New Operations Unlike significant figures, the scale returned does not change as the number of decimal digits are multiplied or divided. This means that multiplying two numbers that each have 10 digits after the decimal will also return a number with 10 digits after the decimal. This can be fixed by setting the scale of the argument value to the sum of the two scales. Scale Is Only Applied To The Base-10 Form Scale is tracked and managed in base-10. This means that if a number has a base smaller than 10, it will return more digits than the scale would suggest after base conversion, while a number with a base larger than 10 will return fewer digits after the base conversion.","title":"Concepts"},{"location":"getting-started/concepts/#concepts","text":"Fermat has some vocabulary and concepts that are unique to this library, and they are documented here.","title":"Concepts"},{"location":"getting-started/concepts/#providers","text":"A provider in Fermat is a static class which provides a specific functionality to the entire library. It makes this interface available using static methods and wherever possible is permissive about the values it accepts as arguments. What is meant by that is you can, in most cases, pass an implementation of NumberInterface, a numeric string, an int, or a float. Please note that there are exceptions to this general principle and consult the method documentation. The current list of providers, documented in more detail in the section for Providers, is: ArithmeticProvider ConstantProvider PolyfillProvider SequenceProvider SeriesProvider StatsProvider TrigonometryProvider See Also The Providers included in Fermat are documented in more detail under \"Reference\".","title":"Providers"},{"location":"getting-started/concepts/#types","text":"A type in Fermat is an implementation of a class of number or math concept. These are (with the exception of Tuple and NumberCollection ) abstract classes that are meant to be extended into classes which can be instantiated. This is mostly to provide both mutable and immutable versions of each type. A Tuple is meant to be inherently immutable, while a NumberCollection is mean to inherently mutable. The current list of types is: ComplexNumber Coordinate Decimal Expression Fraction Matrix NumberCollection Tuple See Also The Types included in Fermat are documented in more detail under \"Types & Values\".","title":"Types"},{"location":"getting-started/concepts/#values","text":"A value in Fermat is a usable implementation that can be directly worked with to perform math operations of some kind. These represent concrete concepts or types of values that have specific intended behavior and usage. The current list of values is: Algebra PolynomialFunction Geometry CoordinateSystems CartesianCoordinate CylindricalCoordinate PolarCoordinate SphericalCoordinate ImmutableComplexNumber ImmutableDecimal ImmutableFraction ImmutableMatrix MutableComplexNumber MutableDecimal MutableFraction MutableMatrix See Also The Values included in Fermat are documented in more detail under \"Types & Values\".","title":"Values"},{"location":"getting-started/concepts/#scale","text":"The basis of this library is being able to provide answers at any requested scale. Scale, as used in this library, is the number of digits after the decimal point which are returned. This is in contrast to significant figures or precision , which represent the numbers of digits returned after the decimal point after trimming all the leading zeros. There are two main reasons for providing scale as the main way of controlling how precise the answer is: It ensures that the string size of values with the same scale are comparable. It is far easier to implement some of the converging series calculations within this library, such as those for trigonometry functions, if scale is used instead of precision. In actual fact, significant figures have much less meaning in the context of a Taylor series or MacLauren series. If precision was used, the library would have to make more assumptions about the intent of calling code, and those assumptions would be less transparent. Scale Does Not Increase With New Operations Unlike significant figures, the scale returned does not change as the number of decimal digits are multiplied or divided. This means that multiplying two numbers that each have 10 digits after the decimal will also return a number with 10 digits after the decimal. This can be fixed by setting the scale of the argument value to the sum of the two scales. Scale Is Only Applied To The Base-10 Form Scale is tracked and managed in base-10. This means that if a number has a base smaller than 10, it will return more digits than the scale would suggest after base conversion, while a number with a base larger than 10 will return fewer digits after the base conversion.","title":"Scale"},{"location":"getting-started/direct-instantiation/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } You can also directly instantiate the Value classes if you wish, and sometimes it is desirable to do so. Mutable vs. Immutable This section details the concrete implementations that are available for the various values in Fermat. Many of these implementations have a Mutable and an Immutable version. For more detailed information about the differences between these, and the situations that each might be useful in, please see the page on mutability . Values of Decimal These classes extend the Decimal abstract class, which comes with the following interfaces, traits, and constructor. Interfaces NumberInterface BaseConversionInterface SimpleNumberInterface DecimalInterface Traits ArithmeticSimpleTrait ArithmeticSelectionTrait ArithmeticScaleTrait ArithmeticNativeTrait ComparisonTrait IntegerMathTrait TrigonometryTrait InverseTrigonometryTrait LogTrait ScaleTrait __construct(mixed $value, int $scale = 10, int $base = 10) $value The value to create the instance with $scale The maximum number of digits after the decimal that the instance can have $base The base of the instance created return An instance of Decimal created with the provided arguments as parameters The constructor will take an integer , a float , or any numeric string (including imaginary values) as its input value. The scale and base must be given as integers, and can be omitted where they will take their default values of 10. This means that by default instances of Decimal will be in base-10 and calculate 10 digits of scale for all operations. You Might Not Expect If an instance of Decimal is provided, it will be treated as a string and will construct correctly. However, it will not inherit the $scale or $base settings for the instance provided as a $value . Warning If the instance provided is in a base other than 10, the $base provided to the constructor should match that value, or you will eventually get exceptions and potentially PHP fatals. Danger Providing an instance of Fraction or ComplexNumber will appear to build the new instance correctly, but will result in a PHP fatal error on calls to any methods on the new instance. ImmutableNumber A number which can be represented as a decimal and has a maximum scale of 2 63 2^{63} 2 63 digits. This value is immutable, and all methods called on instances of the class will return a new instance of the same class while leaving the existing instance at its original value. MutableNumber A number which can be represented as a decimal and has a maximum scale of 2 63 2^{63} 2 63 digits. This value is mutable, and all methods called on instances of the class will return the same instance after modification, while the previous value will be lost. Values of Fraction Used to represent numbers in a fraction format. The / character is used in string representations to denote the fraction bar, and is used to create instances from strings. In these cases, it is assumed that the numerator is to the left of the fraction bar, and the denominator is the right. The numerator and denominator must also be whole numbers. If a mathematical operation results in non-whole values for either the numerator or denominator, the Fraction is converted to a Decimal using the asDecimal() method on the FractionInterface . These classes extend the Fraction abstract class, which comes with the following interfaces, traits, and constructor. Interfaces NumberInterface BaseConversionInterface SimpleNumberInterface FractionInterface Traits ArithmeticSimpleTrait ArithmeticSelectionTrait ArithmeticScaleTrait ArithmeticNativeTrait ComparisonTrait __construct(mixed $numerator, mixed $denominator, $base = 10) $numerator The value of the numerator, using the same restrictions as Decimal $denominator The value of the denominator, using the same restrictions as Decimal $base The base of the instance created return An instance of Fraction created with the provided arguments as parameters The constructor will take an integer , a float , any numeric string , or an instance of DecimalInterface as its input value. The base must be given as an integer, and if omitted it will take the default value of 10. This means that by default instances of Fraction will be in base-10. Rounding In the constructor, non-integer values for the numerator or denominator are automatically rounded to the nearest integer using the \"half up\" method. Type Coercion If an instance implementing DecimalInterface is provided, it will be coerced into an ImmutableDecimal . This will leave the original instance unaffected by operations performed on the Fraction , even if an instance of MutableDecimal was originally provided. ImmutableFraction A number which can be represented as a fraction. This value is immutable, and all methods called on instances of the class will return a new instance of the same class while leaving the existing instance at its original value. MutableFraction A number which can be represented as a fraction. This value is mutable, and all methods called on instances of the class will return the same instance after modification, while the previous value will be lost. Values of ComplexNumber Used to represent complex number values. Either part can be an instance of FractionInterface or DecimalInterface , however while Decimal values can be provided as an object , a string , an integer , or a float , you must explicitly provide an instance of Fraction if you wish for one of the components to be in that format. Unexpected Class Inheritance Structure While the name of this class is ComplexNumber , it does not extend the abstract Number class like Fraction and Decimal do. Instead, it extends PolarCoordinate , since this is an advantageous representation of complex numbers in many situations. The arguments to the ComplexNumber class correspond directly with a set of CartesianCoordinate s. These are then transformed into an instance of PolarCoordinate which is a more useful form for doing operations like pow() and sqrt() . Interfaces ComplexNumberInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends NumberInterface This interface is meant to be implemented by an object which extends PolarCoordinate , since all complex numbers can be represented in that way and there are advantages to doing so. CoordinateInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Coordinates extends TwoDCoordinateInterface This interface provides the base methods available to all coordinate systems. This includes the asCartesian() method, since any type of coordinate system in a Euclidean space can be represented by cartesian coordinates. Non-Euclidean spaces are unsupported in Fermat. Traits ArithmeticComplexTrait namespace Samsara\\Fermat\\Types\\Traits uses ArithmeticScaleTrait ArithmeticNativeTrait ArithmeticSelectionTrat satisfies ComplexNumberInterface (partially) The ArithmeticComplexTrait provides the implementations for all arithmetic functions that exist on values that implement the ComplexNumberInterface . The additional imported traits within this trait provide the various calculation modes that are used internally depending on the mode of object executing the method call. Accepts Simple Numbers as Arguments While the ArithmeticComplexTrait can accept implementations of SimpleNumberInterface as arguments, it cannot be used in implementations of SimpleNumberInterface . See Also More detailed information on this trait is available on the Arithmetic > Complex Numbers page. __construct(mixed $realPart, mixed $imaginaryPart, ?int $scale = null, int $base = 10) $realPart The value of the real part; can be an instance of FractionInterface , and instance of DecimalInterface , or a scalar using the same restrictions as Decimal $imaginaryPart The value of the imaginary part; can be an instance of FractionInterface , and instance of DecimalInterface , or a scalar using the same restrictions as Decimal $scale The maximum number of digits after the decimal that the instance components can have $base The base of the instance created return An instance of ComplexNumber created with the provided arguments as parameters ImmutableComplexNumber A number which can be represented as a complex number. This value is immutable, and all methods called on instances of the class will return a new instance of the same class while leaving the existing instance at its original value. MutableComplexNumber A number which can be represented as a complex number. This value is mutable, and all methods called on instances of the class will return the same instance after modification, while the previous value will be lost. Values of Matrix Used to represent mathematical matrices and perform matrix math. Interfaces Traits __construct(array $data, string $mode = Matrix::MODE_ROWS_INPUT) $data An array of NumberCollection s, defining either the rows or the columns of the matrix; see below for more detailed information $mode Accepts either the string 'rows' or 'columns', defining whether the number in $data are organized as an array of rows or an array of columns return An instance of Matrix created with the provided arguments as parameters The input array has several restrictions and assumptions. The most obvious, given that it is meant to represent matrix data, is that each NumberCollection in the provided array must contain the same number of elements. Further, while the data can represent either the array of rows or array of columns depending on the $mode provided, it will always fill the matrix starting from the upper left corner. This is also the same indexing used by getRow() , getColumn() , or any other function that references a row or column index. ImmutableMatrix MutableMatrix Values of Coordinate The specific interfaces, traits, and constructor for the different values of Coordinate depend on the value class used. This information is detailed in the Types & Values > Coordinates documenation. Coordinates Are Mutable Unlike many other values, all implementations of Coordinate are designed as mutable classes. This design decision was made mainly because of how coordinates are usually used in math. Typically, when an operation of some kind is performed on a coordinate, the resulting coordinate is treated as the only existant value, and previous coordinate is removed from the data set. Mutable implementations mirror this behavior. However, the underlying Decimal values that represent that coordinate components are instances of ImmutableDecimal . This means that while the coordinate instances will be mutable, and decimal instances used as input for the coordinates will remain unaffected. CartesianCoordinate A set of coordinates where each value represents the position along a single plane. These are the coordinates that are most commonly used in algebra and geometry, typically presented in format (x, y) for two-dimensional coordinates, and (x, y, z) for three-dimensional coordinates. CylindricalCoordinate A set of three-dimensional coordinates represented by (r, \u03b8 \\theta \u03b8 , z), where (r, \u03b8 \\theta \u03b8 ) are the polar coordinates of the xy -plane, and (z) is the normal z -coordinate in a Cartesian coordinate representation. This image is licensed under CC-BY-NC-SA-4.0 and was created by Gilbert Strang & Edwin \u201cJed\u201d Herman PolarCoordinate A set of two-dimensional coordinates represented by (r, \u03b8 \\theta \u03b8 ), where (r) is the distance to the origin, and ( \u03b8 \\theta \u03b8 ) is the angle in radians from the positive x -axis. SphericalCoordinate A set of three-dimensional coordinates represented by ( \u03c1 \\rho \u03c1 , \u03b8 \\theta \u03b8 , \u03c6 \\varphi \u03c6 ), where ( \u03c1 \\rho \u03c1 ) is the distance to the origin, ( \u03b8 \\theta \u03b8 ) is the angle in radians from the positive x -axis in the xy -plane, and ( \u03c6 \\varphi \u03c6 ) is the angle in radians from the positive z -axis to the line formed by ( \u03c1 \\rho \u03c1 ). This image is licensed under CC-BY-NC-SA-4.0 and was created by Gilbert Strang & Edwin \u201cJed\u201d Herman","title":"Direct Instantiation"},{"location":"getting-started/direct-instantiation/#values-of-decimal","text":"These classes extend the Decimal abstract class, which comes with the following interfaces, traits, and constructor.","title":"Values of Decimal"},{"location":"getting-started/direct-instantiation/#immutablenumber","text":"A number which can be represented as a decimal and has a maximum scale of 2 63 2^{63} 2 63 digits. This value is immutable, and all methods called on instances of the class will return a new instance of the same class while leaving the existing instance at its original value.","title":"ImmutableNumber"},{"location":"getting-started/direct-instantiation/#mutablenumber","text":"A number which can be represented as a decimal and has a maximum scale of 2 63 2^{63} 2 63 digits. This value is mutable, and all methods called on instances of the class will return the same instance after modification, while the previous value will be lost.","title":"MutableNumber"},{"location":"getting-started/direct-instantiation/#values-of-fraction","text":"Used to represent numbers in a fraction format. The / character is used in string representations to denote the fraction bar, and is used to create instances from strings. In these cases, it is assumed that the numerator is to the left of the fraction bar, and the denominator is the right. The numerator and denominator must also be whole numbers. If a mathematical operation results in non-whole values for either the numerator or denominator, the Fraction is converted to a Decimal using the asDecimal() method on the FractionInterface . These classes extend the Fraction abstract class, which comes with the following interfaces, traits, and constructor.","title":"Values of Fraction"},{"location":"getting-started/direct-instantiation/#immutablefraction","text":"A number which can be represented as a fraction. This value is immutable, and all methods called on instances of the class will return a new instance of the same class while leaving the existing instance at its original value.","title":"ImmutableFraction"},{"location":"getting-started/direct-instantiation/#mutablefraction","text":"A number which can be represented as a fraction. This value is mutable, and all methods called on instances of the class will return the same instance after modification, while the previous value will be lost.","title":"MutableFraction"},{"location":"getting-started/direct-instantiation/#values-of-complexnumber","text":"Used to represent complex number values. Either part can be an instance of FractionInterface or DecimalInterface , however while Decimal values can be provided as an object , a string , an integer , or a float , you must explicitly provide an instance of Fraction if you wish for one of the components to be in that format. Unexpected Class Inheritance Structure While the name of this class is ComplexNumber , it does not extend the abstract Number class like Fraction and Decimal do. Instead, it extends PolarCoordinate , since this is an advantageous representation of complex numbers in many situations. The arguments to the ComplexNumber class correspond directly with a set of CartesianCoordinate s. These are then transformed into an instance of PolarCoordinate which is a more useful form for doing operations like pow() and sqrt() .","title":"Values of ComplexNumber"},{"location":"getting-started/direct-instantiation/#immutablecomplexnumber","text":"A number which can be represented as a complex number. This value is immutable, and all methods called on instances of the class will return a new instance of the same class while leaving the existing instance at its original value.","title":"ImmutableComplexNumber"},{"location":"getting-started/direct-instantiation/#mutablecomplexnumber","text":"A number which can be represented as a complex number. This value is mutable, and all methods called on instances of the class will return the same instance after modification, while the previous value will be lost.","title":"MutableComplexNumber"},{"location":"getting-started/direct-instantiation/#values-of-matrix","text":"Used to represent mathematical matrices and perform matrix math.","title":"Values of Matrix"},{"location":"getting-started/direct-instantiation/#immutablematrix","text":"","title":"ImmutableMatrix"},{"location":"getting-started/direct-instantiation/#mutablematrix","text":"","title":"MutableMatrix"},{"location":"getting-started/direct-instantiation/#values-of-coordinate","text":"The specific interfaces, traits, and constructor for the different values of Coordinate depend on the value class used. This information is detailed in the Types & Values > Coordinates documenation. Coordinates Are Mutable Unlike many other values, all implementations of Coordinate are designed as mutable classes. This design decision was made mainly because of how coordinates are usually used in math. Typically, when an operation of some kind is performed on a coordinate, the resulting coordinate is treated as the only existant value, and previous coordinate is removed from the data set. Mutable implementations mirror this behavior. However, the underlying Decimal values that represent that coordinate components are instances of ImmutableDecimal . This means that while the coordinate instances will be mutable, and decimal instances used as input for the coordinates will remain unaffected.","title":"Values of Coordinate"},{"location":"getting-started/direct-instantiation/#cartesiancoordinate","text":"A set of coordinates where each value represents the position along a single plane. These are the coordinates that are most commonly used in algebra and geometry, typically presented in format (x, y) for two-dimensional coordinates, and (x, y, z) for three-dimensional coordinates.","title":"CartesianCoordinate"},{"location":"getting-started/direct-instantiation/#cylindricalcoordinate","text":"A set of three-dimensional coordinates represented by (r, \u03b8 \\theta \u03b8 , z), where (r, \u03b8 \\theta \u03b8 ) are the polar coordinates of the xy -plane, and (z) is the normal z -coordinate in a Cartesian coordinate representation. This image is licensed under CC-BY-NC-SA-4.0 and was created by Gilbert Strang & Edwin \u201cJed\u201d Herman","title":"CylindricalCoordinate"},{"location":"getting-started/direct-instantiation/#polarcoordinate","text":"A set of two-dimensional coordinates represented by (r, \u03b8 \\theta \u03b8 ), where (r) is the distance to the origin, and ( \u03b8 \\theta \u03b8 ) is the angle in radians from the positive x -axis.","title":"PolarCoordinate"},{"location":"getting-started/direct-instantiation/#sphericalcoordinate","text":"A set of three-dimensional coordinates represented by ( \u03c1 \\rho \u03c1 , \u03b8 \\theta \u03b8 , \u03c6 \\varphi \u03c6 ), where ( \u03c1 \\rho \u03c1 ) is the distance to the origin, ( \u03b8 \\theta \u03b8 ) is the angle in radians from the positive x -axis in the xy -plane, and ( \u03c6 \\varphi \u03c6 ) is the angle in radians from the positive z -axis to the line formed by ( \u03c1 \\rho \u03c1 ). This image is licensed under CC-BY-NC-SA-4.0 and was created by Gilbert Strang & Edwin \u201cJed\u201d Herman","title":"SphericalCoordinate"},{"location":"getting-started/exceptions/","text":"Exceptions Used In This Library The exceptions used in Fermat are all provided by the samsara/common package via composer. This is listed as a dependency in the composer.json. All these exceptions are in the namespace Samsara\\Exceptions . Base Exceptions Base\\SystemError : Extends \\Exception . Used for errors that occur because of errors within the library. Base\\UsageError : Extends \\Exception . Used for errors that occur because of incorrect usage of the library. Thrown Exceptions SystemError\\LogicalError\\IncompatibleObjectState : This exception is thrown when the object is in a state that is incompatible with the requested operation. For example, calling factorial() on a DecimalInterface instance that has a decimal value. SystemError\\PlatformError\\MissingPackage : This exception is thrown when an operation is performed that cannot be completed unless a missing Fermat Module is installed. UsageError\\IntegrityConstraint : This exception is thrown when a data integrity violation is found within a function. Most often this is due to poorly formatted or out of range arguments provided to a function. UsageError\\OptionalExit : This exception is thrown when an error is encountered that may be solved by re-calling the same function with different arguments, for instance by providing a different scale setting. Handling Exceptions From This Library Objects provided in this library are always in a valid state, and any exception thrown results in the object keeping its state from before the function call. Because of this, it may be possible in most situations to use a try/catch block to intelligently handle these exceptions based on the purpose of the numbers and data being provided to the Fermat objects. State Is Preserved Even For Mutable Objects In the event that an exception is thrown, even mutable objects will retain their state from before the method call.","title":"Handling Exceptions"},{"location":"getting-started/exceptions/#exceptions-used-in-this-library","text":"The exceptions used in Fermat are all provided by the samsara/common package via composer. This is listed as a dependency in the composer.json. All these exceptions are in the namespace Samsara\\Exceptions .","title":"Exceptions Used In This Library"},{"location":"getting-started/exceptions/#handling-exceptions-from-this-library","text":"Objects provided in this library are always in a valid state, and any exception thrown results in the object keeping its state from before the function call. Because of this, it may be possible in most situations to use a try/catch block to intelligently handle these exceptions based on the purpose of the numbers and data being provided to the Fermat objects. State Is Preserved Even For Mutable Objects In the event that an exception is thrown, even mutable objects will retain their state from before the method call.","title":"Handling Exceptions From This Library"},{"location":"getting-started/installation-and-usage/","text":"Installation The Fermat library is available on Packagist , and can be installed with composer: composer require samsara/fermat ^2.0 Dependencies Fermat requires the following packages: ircmaxell/random-lib : Provides cross-platform random number generation riimu/kit-baseconversion : Provides the base conversion library used internally samsara/common : Provides the exception model used in Fermat It also requires the BCMath extension for PHP, however since 7.0 this extension has been included by default in distributions. Improve Performance With Suggested Extensions Fermat suggests that you also install the ext-ds extension and the ext-gmp extension. When present, these help reduce memory usage and computation time. Basic Usage A basic usage of the Fermat library is straightforward and simple to use quickly. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 // __construct($value, $scale = 10, $base = 10); 6 $five = new ImmutableDecimal ( 5 , 20 ); 7 8 echo $five -> pow ( '1.2' ) -> sin () -> getValue (); 9 // Prints: 0.57733662664006904181 10 echo $five -> getValue (); 11 // Prints: 5 Once you have your number objects created, you can continue using them with your desired scale. Fluency Both immutable and mutable instances can be used with a fluent interface . With mutable objects, this is due to the class being designed with a fluent interface inherently. With immutable objects, this is due to a new instance of the immutable object being returned. This means that each method call on an immutable object which returns an object represents a new instance being created and returned, a new zval being created by PHP, and a new set of memory being allocated. See Also The \"Types & Values\" section contains extensive detail about the exact ways that the value objects can be used.","title":"Installation & Usage"},{"location":"getting-started/installation-and-usage/#installation","text":"The Fermat library is available on Packagist , and can be installed with composer:","title":"Installation"},{"location":"getting-started/installation-and-usage/#basic-usage","text":"A basic usage of the Fermat library is straightforward and simple to use quickly. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 // __construct($value, $scale = 10, $base = 10); 6 $five = new ImmutableDecimal ( 5 , 20 ); 7 8 echo $five -> pow ( '1.2' ) -> sin () -> getValue (); 9 // Prints: 0.57733662664006904181 10 echo $five -> getValue (); 11 // Prints: 5 Once you have your number objects created, you can continue using them with your desired scale. Fluency Both immutable and mutable instances can be used with a fluent interface . With mutable objects, this is due to the class being designed with a fluent interface inherently. With immutable objects, this is due to a new instance of the immutable object being returned. This means that each method call on an immutable object which returns an object represents a new instance being created and returned, a new zval being created by PHP, and a new set of memory being allocated. See Also The \"Types & Values\" section contains extensive detail about the exact ways that the value objects can be used.","title":"Basic Usage"},{"location":"getting-started/modules/","text":"Modules Modules are packages available within composer that provide additional functionality to the Fermat library. These packages generally cover use cases that are niche or specific enough to be necessary for only particular kinds of programs. The modules can be included and required in any combination. While some modules depend on other modules, those dependencies are described and handled automatically by the composer package definitions. All Modules Support Arbitrary Precision Fermat is at its core built around arbitrary precision. As such, all modules for Fermat also support arbitrary precision and using them will not change the behavior of the various value objects provided in Fermat The MissingPackage Exception There a few functions within the core Fermat library which can perform operations which require one or more of these modules to be installed. When one of these functions is called without the module being installed, a MissingPackage exception is thrown if the operation being performed absolutely requires that module. An example of this would be creating a distribution from a NumberCollection . This is directly supported by the NumberCollection class, but requires the Fermat Stats module to be installed. The Fermat library is unit tested for both scenarios, with and without modules installed, so any functions within Fermat that require a module have that behavior maintained, tested, and supported. Available Modules These are the modules that are currently available on Packagist.org and can be required directly in your project's composer.json file. Fermat Stats Stable The Fermat Stats module has a released stable version and is available to use in production environments. To do so, require v1.0 like so: composer require samsara/fermat-stats:^1.0 The Fermat Stats modules provides various statistics functions and operations. This module has no other dependencies and can be required as a stand-alone addition to Fermat. Many statistical functions are extremely complex, and so the scale setting on your objects tends to have a much larger impact on performance within this module than elsewhere within Fermat or its modules. See Also The Stats section of this documentation contains more detailed information about this module and its behavior. Fermat Coordinate Systems Stable The Fermat Coordinate Systems module has a released stable version and is available to use in production environments. To do so, require v1.0 like so: composer require samsara/fermat-coordinate-systems:^1.0 The Fermat Coordinate Systems module provides various coordinate objects that are aware of their geometric and algebraic relations to each other. This module has no other dependencies and can be required as a stand-alone addition to Fermat. Coordinates and coordinate systems have defined concepts of dimensionality, and certain coordinate systems are only available with a specific number of dimensions. Each dimension is represented by an ImmutableDecimal object which contains the value for that dimension. See Also The Coordinate Systems section of this documentation contains more detailed information about this module and its behavior. Fermat Complex Numbers Unstable The Fermat Complex Numbers module does not have a released stable version and should not be used in a production environment. Imaginary numbers are supported directly by Fermat, but combining imaginary and real numbers into complex numbers is handled by this module. To include this module anyway, require the current development state like so: composer require samsara/fermat-complex-numbers:dev-master The Fermat Complex Numbers module provides support for complex numbers and the mathematical operations that can be performed on them. This is the easiest module to accidentally result in a MissingPackage exception, as doing operations such as add() with two Decimal instances in Fermat can result in a complex number in certain situations. This is unlikely to happen accidentally however, unless your application deals with both imaginary and real numbers at different points. See Also The Complex Numbers section of this documentation contains more detailed information about this module and its behavior. Fermat Algebra Expressions Unstable The Fermat Algebra Expressions module does not have a released stable version and should not be used in a production environment. To include this module anyway, require the current development state like so: composer require samsara/fermat-algebra-expressions:dev-master The Fermat Algebra Expressions module provides support for objects which represent entire algebraic functions, instead of only specific values. This is particularly useful in situations where you want to know the derivatives or integrals of simple algebraic expressions, such a polynomials. See Also The Algebra Expressions section of this documentation contains more detailed information about this module and its behavior.","title":"Modules"},{"location":"getting-started/modules/#modules","text":"Modules are packages available within composer that provide additional functionality to the Fermat library. These packages generally cover use cases that are niche or specific enough to be necessary for only particular kinds of programs. The modules can be included and required in any combination. While some modules depend on other modules, those dependencies are described and handled automatically by the composer package definitions. All Modules Support Arbitrary Precision Fermat is at its core built around arbitrary precision. As such, all modules for Fermat also support arbitrary precision and using them will not change the behavior of the various value objects provided in Fermat The MissingPackage Exception There a few functions within the core Fermat library which can perform operations which require one or more of these modules to be installed. When one of these functions is called without the module being installed, a MissingPackage exception is thrown if the operation being performed absolutely requires that module. An example of this would be creating a distribution from a NumberCollection . This is directly supported by the NumberCollection class, but requires the Fermat Stats module to be installed. The Fermat library is unit tested for both scenarios, with and without modules installed, so any functions within Fermat that require a module have that behavior maintained, tested, and supported.","title":"Modules"},{"location":"getting-started/modules/#available-modules","text":"These are the modules that are currently available on Packagist.org and can be required directly in your project's composer.json file.","title":"Available Modules"},{"location":"getting-started/mutability/","text":"Mutability In PHP Mutability is a property of instances of objects in object oriented languages. It refers to whether or not a method on the object changes the data referenced by that object's pointer (or in the case of PHP, its zval). If the method changes the data referenced by the object's zval, it is considered to be mutable. If the method does not change the data referenced, it is considered immutable. In general, mutable objects have no memory of their previous states and evolve with the code as more operations are performed on them. Most objects that represent database results are mutable, such as those used in Doctrine or Eloquent. This reflects two properties of database results: A change in the data should still point to the same database entry. There should only ever be one set of data associated with a single database entry. Thus, mutability is not a situation where all objects should be one way or the other, rather it depends on what the meaning of the data contained in the object is. In PHP, mutability comes with the additional issue of scoping. For most purposes, objects can be treated as if they are passed by-reference at all times. See Also The PHP Documentation contains examples on the specifics of how objects are passed between scopes. While it isn't exactly the same as passing by reference, it behaves in a very similar way in most situations. See the php.net page for more information. This is not an issue for some applications, mainly those where all operations are treated as atomic. However, this is not the case for many mathematical operations. Mutability In Fermat Because of these factors, mutability in Fermat is generally left up to the developer using the library. Both mutable and immutable implementations are provided for most values, and the developer using Fermat is asked to choose which type they want at the time it is created. Mutables Are For Niche Use-Cases In This Library Although there are real use-cases for having a mutable numeric value, as detailed within this page, mutables generally make little sense for numeric types, such as integer or float . The values in this library should be treated more like numeric types that have fluent object interfaces than like normal PHP objects. For this reason, most developers in most situations should use the immutable types provided in this library. Immutables are returned automatically in all situations where the library generates or creates a number, such as from the SequenceProvider or from Numbers::makePi() . Unless you are absolutely certain that your use-case calls for a mutable numeric, it is generally safer to use the immutable values. Mutables have been provided to support specific behaviors seen for native integer and float types, namely reassignment operators like += and /= . The exceptions to this rule are usually noted within this documentation, and nearly always represent an underlying data-structure that should always be treated one way or the other. In other cases, such as with implementations of the Coordinate abstract class, the reasons for making all the value classes one way or the other are related to the underlying math concepts they are meant to represent having some of the same properties as database results: that they should always point to the same dataset and that there should only ever be one representation of a given dataset. Choosing Between The Two Which format you use is entirely up to you, but there are some situations that lend themselves more to one instead of the other. First, lets look at the differences in your code that using one or the other might cause by taking the number 5 and adding 10. Example 1: Basic Usage Of Both Immutable 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $balance = new ImmutableDecimal ( 5 ); 6 7 $newBalance = $balance -> add ( 10 ); 8 9 echo 'Current Balance: ' . $newBalance -> getValue (); 10 // Prints: 'Current Balance: 15' Mutable 1 <?php 2 3 use Samsara\\Fermat\\Values\\MutableDecimal ; 4 5 $balance = new MutableDecimal ( 5 ); 6 7 $balance -> add ( 10 ); 8 9 echo 'Current Balance: ' . $balance -> getValue (); 10 // Prints: 'Current Balance: 15' How To Create Equivalence Between the Two In general, you can get the behavior of mutable objects with immutable objects by reassigning the new value to the same variable. This allows the state of the variable to evolve throughout the program, and results in the instance that was referenced in the previous line having its zval count reduced to zero. This allows garbage collection in PHP to periodically clean up all your orphaned instances. So then, why ever use immutable objects? It seems like using immutables will use a much larger amount of memory while doing the same exact thing. Well, consider the next example. Example 2: Side Effects Immutable 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $oldBalance = new ImmutableDecimal ( 5 ); 6 $deposit = new ImmutableDecimal ( 10 ); 7 8 $newBalance = $oldBalance -> add ( $deposit ); 9 10 echo 'Original Balance: ' . $oldBalance . PHP_EOL ; 11 echo 'Deposit: ' . $deposit . PHP_EOL ; 12 echo 'Current Balance: ' . $newBalance ; 13 // Prints: 14 // Original Balance: 5 15 // Deposit: 10 16 // Current Balance: 15 Mutable 1 <?php 2 3 use Samsara\\Fermat\\Values\\MutableDecimal ; 4 5 $oldBalance = new MutableDecimal ( 5 ); 6 $deposit = new MutableDecimal ( 10 ); 7 8 $newBalance = $oldBalance -> add ( $deposit ); 9 10 echo 'Original Balance: ' . $oldBalance . PHP_EOL ; 11 echo 'Deposit: ' . $deposit . PHP_EOL ; 12 echo 'Current Balance: ' . $newBalance ; 13 // Prints: 14 // Original Balance: 15 15 // Deposit: 10 16 // Current Balance: 15 Side Effects and Consistency As we can see from the second set of examples, assigning a value from a mutable function call can have side effects beyond the variable assignment . In fact, preserving the value of the original object requires a lot of attention to detail in the calling code. To achieve the same result as the immutable example with the mutable example, we would need to make a whole new object just for the calculation, which would look something like this: Example 3: Mutables Used Without Side Effects 1 <?php 2 use Samsara\\Fermat\\Values\\MutableDecimal ; 3 4 $oldBalance = new MutableDecimal ( 5 ); 5 $deposit = new MutableDecimal ( 10 ); 6 7 $newBalance = new MutableDecimal ( $oldBalance -> getValue ()); 8 $newBalance -> add ( $deposit ); 9 10 echo 'Original Balance: ' . $oldBalance . PHP_EOL ; 11 echo 'Deposit: ' . $deposit . PHP_EOL ; 12 echo 'Current Balance: ' . $newBalance ; 13 // Prints: 14 // Original Balance: 5 15 // Deposit: 10 16 // Current Balance: 15 Creating a new object on the fly to perform a calculation is in fact exactly how the implementation of immutables in Fermat is accomplished. Internally, any time a calculation has been performed, the new string with the resulting answer is stored in a newly created instance, instead of the instance that initiated the calculation. This can be seen if you look at the different implementations of the setValue() abstract method in the ImmutableDecimal and MutableDecimal classes. Implementations Of setValue() ImmutableDecimal 1 <?php 2 class ImmutableDecimal { 3 protected function setValue ( $value , $scale = null , $base = 10 ) 4 { 5 /* omitted transformations and sanity checks */ 6 7 return new ImmutableDecimal ( $value , $scale , $base ); 8 } 9 } MutableDecimal 1 <?php 2 class MutableDecimal { 3 protected function setValue ( $value , $scale = null , $base = 10 ) 4 { 5 /* omitted transformations and sanity checks */ 6 7 $this -> value = $this -> translateValue ( $value ); 8 9 return $this ; 10 } 11 } The ImmutableDecimal implementation returns a new instance, while the MutableDecimal implementation sets the internal $value property directly and returns the current instance. This is the only meaningful difference between the two classes. setValue() As A Protected Method For both mutable and immutable values, the setValue() method has a visibility of protected , preventing the calling scope from using it. This is intentional, as the values in these objects are meant to represent something closer to a memory address than a normal variable. Allowing setValue() to be called directly, even for mutable objects, could lead to some of the same problems that make memory address safety an issue for desktop applications. Each instance can instead be seen as a Finite-State Machine that evolves according to the state transitions defined on the object, i.e. the mathematical methods that are available on that class. This correctly reflects how math itself works, and helps prevent the developer from accidentally \"breaking\" math by inadvertantly inserting erroneous data in the middle of a series of calculations. In this way, the immutable values act as time saving measures and sanity preserving measures in the case that you want to ensure side effects don't occur. Instead of manually creating new instances for every calculation and running the risk of forgetting on one line in a large program, you can simply request an instance of ImmutableDecimal and it will do so automatically. The downside to this is that the newly created object is not referenced anywhere except in the return value. Without a reference, the object becomes inaccessible if you do not assign the returned result to a variable in the calling scope. Guidelines On When To Use Each Again, the exact usage of either is up to the developer, and it is possible to accomplish the same end result with either if the right design patterns are used. However, below is a brief rundown of when each is generally preferable. Mutables May Be Preferred When The number represents a physical state or evolving state that can only move in one direction, such as with a hashing function The number represents a value which always depends on its previous value, such as recursively calculating a sum, or compiling changes to a total from a ledger of financial entries The number represents a value that has defined state-dependent behavior, such as in a State Machine Immutables May Be Preferred When The number represents data that may be used in multiple, unrelated contexts, such as using a User ID to calculate other values The number represents a concrete state, and the result of the equation will be a derived or dynamically generated value that doesn't actually exist within the data, such as using a population value to estimate average income The number represents a value that may be used multiple times for separate calculations without changing, such as the mean in a normal distribution In general, for any given situation, one of these options will lead to cleaner, simpler, and easier to maintain code, while the other will lead to more fragile, harder to understand, and difficult to maintain code. Which is which depends very much on the specific usage of that piece of data within your application.","title":"Mutable vs. Immutable"},{"location":"getting-started/mutability/#mutability-in-php","text":"Mutability is a property of instances of objects in object oriented languages. It refers to whether or not a method on the object changes the data referenced by that object's pointer (or in the case of PHP, its zval). If the method changes the data referenced by the object's zval, it is considered to be mutable. If the method does not change the data referenced, it is considered immutable. In general, mutable objects have no memory of their previous states and evolve with the code as more operations are performed on them. Most objects that represent database results are mutable, such as those used in Doctrine or Eloquent. This reflects two properties of database results: A change in the data should still point to the same database entry. There should only ever be one set of data associated with a single database entry. Thus, mutability is not a situation where all objects should be one way or the other, rather it depends on what the meaning of the data contained in the object is. In PHP, mutability comes with the additional issue of scoping. For most purposes, objects can be treated as if they are passed by-reference at all times. See Also The PHP Documentation contains examples on the specifics of how objects are passed between scopes. While it isn't exactly the same as passing by reference, it behaves in a very similar way in most situations. See the php.net page for more information. This is not an issue for some applications, mainly those where all operations are treated as atomic. However, this is not the case for many mathematical operations.","title":"Mutability In PHP"},{"location":"getting-started/mutability/#mutability-in-fermat","text":"Because of these factors, mutability in Fermat is generally left up to the developer using the library. Both mutable and immutable implementations are provided for most values, and the developer using Fermat is asked to choose which type they want at the time it is created. Mutables Are For Niche Use-Cases In This Library Although there are real use-cases for having a mutable numeric value, as detailed within this page, mutables generally make little sense for numeric types, such as integer or float . The values in this library should be treated more like numeric types that have fluent object interfaces than like normal PHP objects. For this reason, most developers in most situations should use the immutable types provided in this library. Immutables are returned automatically in all situations where the library generates or creates a number, such as from the SequenceProvider or from Numbers::makePi() . Unless you are absolutely certain that your use-case calls for a mutable numeric, it is generally safer to use the immutable values. Mutables have been provided to support specific behaviors seen for native integer and float types, namely reassignment operators like += and /= . The exceptions to this rule are usually noted within this documentation, and nearly always represent an underlying data-structure that should always be treated one way or the other. In other cases, such as with implementations of the Coordinate abstract class, the reasons for making all the value classes one way or the other are related to the underlying math concepts they are meant to represent having some of the same properties as database results: that they should always point to the same dataset and that there should only ever be one representation of a given dataset.","title":"Mutability In Fermat"},{"location":"getting-started/mutability/#choosing-between-the-two","text":"Which format you use is entirely up to you, but there are some situations that lend themselves more to one instead of the other. First, lets look at the differences in your code that using one or the other might cause by taking the number 5 and adding 10. Example 1: Basic Usage Of Both Immutable 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableDecimal ; 4 5 $balance = new ImmutableDecimal ( 5 ); 6 7 $newBalance = $balance -> add ( 10 ); 8 9 echo 'Current Balance: ' . $newBalance -> getValue (); 10 // Prints: 'Current Balance: 15' Mutable 1 <?php 2 3 use Samsara\\Fermat\\Values\\MutableDecimal ; 4 5 $balance = new MutableDecimal ( 5 ); 6 7 $balance -> add ( 10 ); 8 9 echo 'Current Balance: ' . $balance -> getValue (); 10 // Prints: 'Current Balance: 15'","title":"Choosing Between The Two"},{"location":"getting-started/random-values/","text":"","title":"Random values"},{"location":"getting-started/using-factories/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } Fermat provides factory classes to make it easier to get instances of the various Value classes. The available factories are: Samsara\\Fermat\\Collections Samsara\\Fermat\\Numbers All factories are classes that have only static methods and constants. The Collections Factory Class The Samsara\\Fermat\\Collections factory class currently has no methods or constants, and exists as a placeholder. The Numbers Factory Class The Samsara\\Fermat\\Numbers factory class provides a way to use the Value classes which implement the SimpleNumberInterface in Fermat without being as specific as those classes may require. Consider the following code: Available Constants The following constants are available on the Numbers class. Numbers::IMMUTABLE type string value The fully qualified class name of the ImmutableDecimal class. Numbers::MUTABLE type string value The fully qualified class name of the MutableDecimal class. Numbers::IMMUTABLE_FRACTION type string value The fully qualified class name of the ImmutableFraction class. Numbers::MUTABLE_FRACTION type string value The fully qualified class name of the MutableFraction class. Numbers::PI type string value The value of the constant pi ( \u03c0 \\pi \u03c0 ) pre-computed to 100 decimal places. Numbers::TAU type string value The value of the constant tau ( \u03c4 \\tau \u03c4 ) pre-computed to 100 decimal places. This is equivalent to ( 2 \u03c0 2\\pi 2 \u03c0 ). Numbers::E type string value The value of Euler's constant ( e e e ) pre-computed to 100 decimal places. Numbers::GOLDEN_RATIO type string value The value of the Golden Ratio ( \u03c6 \\varphi \u03c6 ) pre-computed to 100 decimal places. Numbers::LN_10 type string value The value of the natural logarithm of 10 pre-computed to 100 decimal places. Numbers::IMMUTABLE type string value The value of i i i^i i i pre-computed to 100 decimal places. Available Factory Methods The following factory methods are available on the Numbers class. Numbers::make(string $type, mixed $value, ?int $scale = null, int $base = 10) $type The type of SimpleNumberInterface implementation to create $value The value to create the instance with $scale The maximum number of digits after the decimal that the instance can have $base The base of the instance created return An instance of the specified $type created with the provided arguments as parameters This factory method returns an instance of DecimalInterface or FractionInterface , depending on the $type given and the $value provided. Type Can Be An Instance Instead of providing a fully qualified class name for $type , you can provide an instance of a supported object. The make() function will attempt to force the $value into that type. Type Must Be A Supported FQCN or Class If $type is the fully qualified class name or instance of an object other than ImmutableDecimal , MutableDecimal , ImmutableFraction , or MutableFraction , an exception of type Samsara\\Exceptions\\UsageError\\IntegrityConstraint is thrown. Numbers::makeFromBase10(string $type, mixed $value, ?int $scale = null, int $base = 10) $type The type of SimpleNumberInterface implementation to create $value The value to create the instance with $scale The maximum number of digits after the decimal that the instance can have $base The base of the instance created return An instance of the specified $type created with the provided arguments as parameters This factory method will created a base-10 instance of $type using the provided $value , then convert that value in the $base provided. This allows you to provide a $value in base-10, but get an instance in a different base. Numbers::makeOrDont(string $type, mixed $value, ?int $scale = null, int $base = 10) $type The type of SimpleNumberInterface implementation to ensure $value The original value which was provided $scale The maximum number of digits after the decimal that the instance can have $base The base of the instance created return An instance of the specified $type with the provided $value ; if a new instance is created, it has the given $scale and $base This factory method will coerce the given $value into the requested $type . Unlike using direct instantiation , this factory will perform all the correct conversions on the various possible values necessary to ensure a valid instance is constructed. If the provided $value already matches the requested $type , then it is returned without modification. This makes the makeOrDont() factory ideal for accepting any possible valid constructor value as an input while also guaranteeing that your implementation is working with a particular value. This is how the math operations such as add($num) are able to accept virtually any input directly. Arrays of Values An array can be provided as the $value argument to this function. If it is, then a recursive call on Numbers::makeOrDont() is made. This will be done at any level of nested arrays. Low Cost Function Call This factory method returns the provided value after only making a call to is_object() and a single use of instanceof if the provided $value matches the requested $type . In general, it is written to build the requested $type in the most efficient way possible given the provided inputs. This makes calls to this factory method very low cost from both a memory and computation perspective if you need the value to be a guaranteed instance of a particular class. Mixed Argument Limitations The $values argument is listed in this documentation as mixed . In fact, the valid input types are: An integer A float A string that contains only a single number in base 10 A string that contains only a single number in base 10 with the i character at the end, denoting an imaginary value An object that implements NumberInterface If the provided $value matches none of these, an exception of type Samsara\\Exceptions\\UsageError\\IntegrityConstraint is thrown. Numbers::makeFractionFromString(string $type, string $value, int $base = 10) $type The type of SimpleNumberInterface implementation to ensure $value The original value which was provided $base The base of the instance created return An instance of the specified FractionInterface class with the provided arguments as parameters; translates the string $value into the correct constructor arguments This factory method will take a string as its input and provide an instance of either ImmutableFraction or MutableFraction depending on the value given for $type . Type Must Be A Supported FQCN If $type is the fully qualified class name of an object other than ImmutableFraction or MutableFraction , an exception of type Samsara\\Exceptions\\UsageError\\IntegrityConstraint is thrown. Value Must Contain at Most One Fraction Bar '/' If $value contains more than one fraction bar, which is assumed to be represented by the character / , an exception of type Samsara\\Exceptions\\UsageError\\IntegrityConstraint is thrown. Numbers::makePi(?int $scale = null) $scale The maximum number of digits after the decimal that the instance can have return The number pi ( \u03c0 \\pi \u03c0 ) as an instance of ImmutableNumber to the requested $scale . If no $scale is given, then the value is returned with a scale of 100. If a scale of 100 or less is requested, then the instance is constructed from the Numbers::PI constant. If a scale of greater than 100 is requested, then a call is made to ConstantProvider::makePi() which computes digits of pi using the most efficient computational method currently available. Scale Must Be Positive If a scale of less than 1 is requested, an exception of type Samsara\\Exceptions\\UsageError\\IntegrityConstraint is thrown. Numbers::makeTau(?int $scale = null) $scale The maximum number of digits after the decimal that the instance can have return The number tau ( \u03c4 \\tau \u03c4 ) as an instance of ImmutableNumber to the requested $scale . If no $scale is given, then the value is returned with a scale of 100. If a scale of 100 or less is requested, then the instance is constructed from the Numbers::TAU constant. If a scale of greater than 100 is requested, then a call is made to Numbers::makePi() which uses the methods described above, after which the result is multiplied by 2. Scale Must Be Positive If a scale of less than 1 is requested, an exception of type Samsara\\Exceptions\\UsageError\\IntegrityConstraint is thrown. Numbers::make2Pi(?int $scale = null) $scale The maximum number of digits after the decimal that the instance can have return The number 2pi ( 2 \u03c0 2\\pi 2 \u03c0 ) as an instance of ImmutableNumber to the requested $scale . This factory method is an alias for Numbers::makeTau() . Scale Must Be Positive If a scale of less than 1 is requested, an exception of type Samsara\\Exceptions\\UsageError\\IntegrityConstraint is thrown. Numbers::makeE(?int $scale = null) $scale The maximum number of digits after the decimal that the instance can have return Euler's number ( e e e ) as an instance of ImmutableNumber to the requested $scale . If no $scale is given, then the value is returned with a scale of 100. If a scale of 100 or less is requested, then the instance is constructed from the Numbers::E constant. If a scale of greater than 100 is requested, then a call is made to ConstantProvider::makeE() which uses a fast converging series to calculate digits of e. Scale Must Be Positive If a scale of less than 1 is requested, an exception of type Samsara\\Exceptions\\UsageError\\IntegrityConstraint is thrown. Numbers::makeGoldenRatio(?int $scale = null) $scale The maximum number of digits after the decimal that the instance can have return The golden ratio ( \u03c6 \\varphi \u03c6 ) as an instance of ImmutableNumber to the requested $scale . If no $scale is given, then the value is returned with a scale of 100. If a scale of 100 or less is requested, then the instance is constructed from the Numbers::GOLDEN_RATION constant. Scale Must Be 1-100 If a scale of less than 1 or greater than 100 is requested, an exception of type Samsara\\Exceptions\\UsageError\\IntegrityConstraint is thrown. Numbers::makeNaturalLog10(?int $scale = null) $scale The maximum number of digits after the decimal that the instance can have return The natural log of 10 as an instance of ImmutableNumber to the requested $scale . If no $scale is given, then the value is returned with a scale of 100. If a scale of 100 or less is requested, then the instance is constructed from the Numbers::LN_10 constant. If a scale of greater than 100 is requested, then an exception is thrown. Scale Must Be 1-100 If a scale of less than 1 or greater than 100 is requested, an exception of type Samsara\\Exceptions\\UsageError\\IntegrityConstraint is thrown. Numbers::makeOne(?int $scale = null) $scale The maximum number of digits after the decimal that the instance can have return The number 1 as an instance of ImmutableNumber to the requested $scale . If $scale is null, then the instance returned will have a scale of 100. Numbers::makeZero(?int $scale = null) $scale The maximum number of digits after the decimal that the instance can have return The number 0 as an instance of ImmutableNumber to the requested $scale . If $scale is null, then the instance returned will have a scale of 100. Static Methods The Numbers factory class also has two static methods that work as a global variable for the Fermat library. Numbers::getDefaultCalcMode() return The current value of the protected parameter Numbers::$defaultCalcMode By default, this value is set to Selectable::CALC_MODE_PRECISION , resulting in the arbitrary scale implementations being used for all math functions. For Internal Use This function is meant to be called within the constructors of values that implement the NumberInterface and which use the provided arithmetic traits. It is likely to have limited utility outside of these situations. Numbers::setDefaultCalcMode(int $mode) $mode The calculation mode integer; expected to match constant values on Selectable return Void This static method sets the protected parameter Numbers::$defaultCalcMode to the provided $mode . The Fermat library assumes that only values which are constants on the Selectable class are used as inputs for this function. Using other values for $mode may be possible in the event you are extending the Fermat classes with your own implementations, however an unknown $mode will cause the classes provided in this library to fall back to Selectable::CALC_MODE_PRECISION . This behavior could be changed by overriding the methods defined in the ArithmeticSelectionTrait . See Also For more information on the calculation modes available in Fermat, see the page on Calculation Modes . For more information on extending these values, please see the documentation in the \"Extending\" section.","title":"Using The Factories"},{"location":"getting-started/using-factories/#the-collections-factory-class","text":"The Samsara\\Fermat\\Collections factory class currently has no methods or constants, and exists as a placeholder.","title":"The Collections Factory Class"},{"location":"getting-started/using-factories/#the-numbers-factory-class","text":"The Samsara\\Fermat\\Numbers factory class provides a way to use the Value classes which implement the SimpleNumberInterface in Fermat without being as specific as those classes may require. Consider the following code:","title":"The Numbers Factory Class"},{"location":"modules/algebra-expressions/about/","text":"","title":"About"},{"location":"modules/complex-numbers/about/","text":"","title":"About"},{"location":"modules/complex-numbers/factory-class/","text":"The ComplexNumbers Factory Class The Samsara\\Fermat\\ComplexNumbers factory class allows you to create instances of the Value classes which implement the ComplexNumberInterface . Available Constants The following constants are available on the ComplexNumbers class. ComplexNumbers::IMMUTABLE_COMPLEX type string value The fully qualified class name of the ImmutableComplexNumber class. ComplexNumbers::MUTABLE_COMPLEX type string value The fully qualified class name of the MutableComplexNumber class. Available Factory Methods The following factory methods are available on the ComplexNumbers class. ComplexNumbers::make(string $type, string|array|NumberCollectionInterface $value) $type The type (mutable or immutable) of ComplexNumber to create $value The initial value of the created instance; see notes below return The instance created from the given inputs; the instance will extend ComplexNumber and implement the ComplexNumberInterface If the value is a string , it is assumed to be in the format: REAL+IMAGINARY or REAL-IMAGINARY Note In string format, the input for this factory method MAY have a minus sign in front of the real part, but MUST have either a plus or minus sign in front of the imaginary part. 1 The sign is applied to the number that follows and is stored in the `ImmutableDecimal` for that number. You may also provide either an array or a NumberCollection that have exactly two values which implement the SimpleNumberInterface . Warning The real part must have a key of 0 , and the imaginary part must have a key of 1 in the given array or NumberCollection .","title":"The ComplexNumbers Factory Class"},{"location":"modules/complex-numbers/factory-class/#the-complexnumbers-factory-class","text":"The Samsara\\Fermat\\ComplexNumbers factory class allows you to create instances of the Value classes which implement the ComplexNumberInterface .","title":"The ComplexNumbers Factory Class"},{"location":"modules/coordinate-systems/about/","text":"","title":"About"},{"location":"modules/linear-algebra/matrix-factory/","text":"The Matrices Factory Class The Samsara\\Fermat\\Matrices factory class provides access to several pre-built matrices that may be useful in common situations. Available Constants The following constants are available on the Matrices class. Matrices::IMMUTABLE_MATRIX type string value The fully qualified class name of the ImmutableMatrix class. Matrices::MUTABLE_MATRIX type string value The fully qualified class name of the MutableMatrix class. Available Factory Methods The following factory methods are available on the Matrices class. Matrices::zeroMatrix(string $type, int $rows, int $columns) $type The type (mutable or immutable) of Matrix to create $rows The number of rows the generated matrix should have $columns The number of columns the generated matrix should have return An instance of the specified matrix type with the given dimensions where all values in the matrix are the number zero For Example A zero matrix of two rows and three columns would look like: 1 ``` 2 [0 0 0] 3 [0 0 0] 4 ``` Matrices::onesMatrix(string $type, int $rows, int $columns) $type The type (mutable or immutable) of Matrix to create $rows The number of rows the generated matrix should have $columns The number of columns the generated matrix should have return An instance of the specified matrix type with the given dimensions where all values in the matrix are the number one For Example A ones matrix of two rows and three columns would look like: 1 ``` 2 [1 1 1] 3 [1 1 1] 4 ``` Matrices::identityMatrix(string $type, int $size) $type The type (mutable or immutable) of Matrix to create $size The number of rows and columns the generated matrix should have return A square matrix where the dimensions match the integer given in $size . This matrix is an identity matrix, which is often used in matrix math, where the diagonal consists of ones, and all other values are zero For Example An identity matrix of size three would look like: 1 ``` 2 [1 0 0] 3 [0 1 0] 4 [0 0 1] 5 ``` Matrices::cofactorMatrix(string $type, int $size) $type The type (mutable or immutable) of Matrix to create $size The number of rows and columns the generated matrix should have return A square matrix where the dimensions match the integer given in $size . The matrix is filled with alternating values of 1 and -1 in a checkerboard pattern, starting with positive 1 in position [0, 0]. When multiplied by another matrix, this will swap the sign of every other value in the matrix. For Example A cofactor matrix of size three would look like: 1 ``` 2 [+ - +] 3 [- + -] 4 [+ - +] 5 ```","title":"The Matrices Factory Class"},{"location":"modules/linear-algebra/matrix-factory/#the-matrices-factory-class","text":"The Samsara\\Fermat\\Matrices factory class provides access to several pre-built matrices that may be useful in common situations.","title":"The Matrices Factory Class"},{"location":"modules/stats/about/","text":"","title":"About"},{"location":"reference/distributions/","text":"","title":"Index"},{"location":"reference/interfaces/characteristics/","text":"Characteristics Interfaces BaseConversionInterface","title":"Characteristics"},{"location":"reference/interfaces/characteristics/#characteristics-interfaces","text":"","title":"Characteristics Interfaces"},{"location":"reference/interfaces/characteristics/#baseconversioninterface","text":"","title":"BaseConversionInterface"},{"location":"reference/interfaces/coordinates/","text":"Coordinate Interfaces CoordinateInterface ThreeDCoordinateInterface TwoDCoordinateInterface","title":"Coordinates"},{"location":"reference/interfaces/coordinates/#coordinate-interfaces","text":"","title":"Coordinate Interfaces"},{"location":"reference/interfaces/coordinates/#coordinateinterface","text":"","title":"CoordinateInterface"},{"location":"reference/interfaces/evaluateables/","text":"Evaluateable Interfaces ExpressionInterface FunctionInterface","title":"Evaluateables"},{"location":"reference/interfaces/evaluateables/#evaluateable-interfaces","text":"","title":"Evaluateable Interfaces"},{"location":"reference/interfaces/evaluateables/#expressioninterface","text":"","title":"ExpressionInterface"},{"location":"reference/interfaces/evaluateables/#functioninterface","text":"","title":"FunctionInterface"},{"location":"reference/interfaces/groups/","text":"Group Interfaces MatrixInterface NumberCollectionInterface","title":"Groups"},{"location":"reference/interfaces/groups/#group-interfaces","text":"","title":"Group Interfaces"},{"location":"reference/interfaces/groups/#matrixinterface","text":"","title":"MatrixInterface"},{"location":"reference/interfaces/groups/#numbercollectioninterface","text":"","title":"NumberCollectionInterface"},{"location":"reference/interfaces/numbers/","text":"Number Interfaces These interfaces represent objects that contain individual numbers of some kind. NumberInterface is the base for this section, and all the other interfaces extend it. Keep In Mind Many places within this library code against the interfaces provided. Generally a value object should implement one of the composite interfaces, such as DecimalInterface , while a function which accepts an argument should require something like the SimpleNumberInterface . If you implement your own value classes, you need to implement the appropriate interface to use it with the rest of this library. A value function should never implement only NumberInterface . NumberInterface abs(): SimpleNumberInterface Applies the absolute value function to the current object and returns the object. Immutable objects will return a new instance that contains the absolute value, and mutable objects will apply the absolute value to the current instance. absValue(): string Applies the absolute value function to the current object and returns the result as a string. This will never alter the existing object. add(int|float|numeric|NumberInterface $num): self This adds the argument to the Value using the ArithmeticProvider or the native + operator depending on the calculation mode of the original object. For further information, see the section on Arithmetic . SimpleNumberInterface DecimalInterface FractionInterface ComplexNumberInterface","title":"Numbers"},{"location":"reference/interfaces/numbers/#number-interfaces","text":"These interfaces represent objects that contain individual numbers of some kind. NumberInterface is the base for this section, and all the other interfaces extend it. Keep In Mind Many places within this library code against the interfaces provided. Generally a value object should implement one of the composite interfaces, such as DecimalInterface , while a function which accepts an argument should require something like the SimpleNumberInterface . If you implement your own value classes, you need to implement the appropriate interface to use it with the rest of this library. A value function should never implement only NumberInterface .","title":"Number Interfaces"},{"location":"reference/interfaces/numbers/#numberinterface","text":"","title":"NumberInterface"},{"location":"reference/providers/","text":"","title":"Index"},{"location":"reference/providers/rounding/","text":"The Rounding Provider The rounding provider allows you to round a number of arbitrary precision and scale using one of several rounding modes. Available Constants The following constants are available on the RoundProvider class. RoundingProvider::MODE_HALF_UP type integer value 1 RoundingProvider::MODE_HALF_DOWN type integer value 2 RoundingProvider::MODE_HALF_EVEN type integer value 3 RoundingProvider::MODE_HALF_ODD type integer value 4 RoundingProvider::MODE_HALF_ZERO type integer value 5 RoundingProvider::MODE_HALF_INF type integer value 6 RoundingProvider::MODE_CEIL type integer value 7 RoundingProvider::MODE_FLOOR type integer value 8 RoundingProvider::MODE_RANDOM type integer value 9 RoundingProvider::MODE_ALTERNATING type integer value 10 RoundingProvider::MODE_STOCHASTIC type integer value 11 Available Public Static Methods The following public static methods are available on the RoundingProvider class. RoundingProvider::round(DecimalInterface $decimal, int $places = 0) $decimal The number being rounded. It must be an instance of a class that implements DecimalInterface . $places The number of places after the decimal to begin rounding. For rounding to the nearest integer, provide zero for this parameter. To round to the nearest hundred you would provide -2. return The string of the rounded number RoundingProvider::getRoundingMode() return The integer corresponding to the current rounding mode. This can be compared to the class constants. RoundingProvider::setRoundingMode(int $mode) $mode The mode flag to use in future rounding calls. Intended to be used in conjunction with the class constants. return void","title":"Rounding"},{"location":"reference/providers/rounding/#the-rounding-provider","text":"The rounding provider allows you to round a number of arbitrary precision and scale using one of several rounding modes.","title":"The Rounding Provider"},{"location":"snippets/has-interface/base-conversion/","text":"BaseConversionInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Characteristics BaseConversionInterface enables two methods: convertToBase() and getBase() , which do exactly what someone would expect them to. Base Conversion is Done Just-In-Time Internally, the values of objects which implement the BaseConversionInterface always store the number in base-10, since this is the only base that arithmetic can actually be performed in by any of the associated extensions. Base conversion happens when a call is made to getValue() . Even on objects which have a base other than base-10, this can be avoided by calls to getAsBaseTenNumber() and getAsBaseTenRealNumber() .","title":"Base conversion"},{"location":"snippets/has-interface/complex-number/","text":"ComplexNumberInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends NumberInterface This interface is meant to be implemented by an object which extends PolarCoordinate , since all complex numbers can be represented in that way and there are advantages to doing so.","title":"Complex number"},{"location":"snippets/has-interface/coordinate/","text":"CoordinateInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Coordinates extends TwoDCoordinateInterface This interface provides the base methods available to all coordinate systems. This includes the asCartesian() method, since any type of coordinate system in a Euclidean space can be represented by cartesian coordinates. Non-Euclidean spaces are unsupported in Fermat.","title":"Coordinate"},{"location":"snippets/has-interface/decimal/","text":"DecimalInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends SimpleNumberInterface which extends NumberInterface The DecimalInterface extends SimpleNumberInterface and adds the methods that are common to all decimal values. This includes trigonometric operations, integer operations such as factorial() or isPrime() , integer and float comparisons and conversions, rounding and truncating functions, and log functions. While some of these can be done on fractions in pure mathematics, such as trigonometry functions, in practice computers are not well-equipped to handle the algorithms for them without actually performing the division implied by the fraction. Thus, to use these types of functions an explicit call to asDecimal() must first be made on classes that implement Fraction . See Also The page for Types & Values > Fractions contains more information on the limitations of fraction representations within Fermat.","title":"Decimal"},{"location":"snippets/has-interface/fraction/","text":"FractionInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends SimpleNumberInterface which extends NumberInterface The FractionInterface extends SimpleNumberInterface and adds the methods that are common to all fraction values. This includes simplify() , accessors for the numerator and denominator, and the asDecimal() method that returns the Fraction as an instance of DecimalInterface . ImmutableDecimals Are Returned From asDecimal() While the interface only defines the DecimalInterface as a return value, the concrete classes returned by all included implementations are instances of ImmutableDecimal . While some other functions can be done on fractions in pure mathematics, such as trigonometry functions, in practice computers are not well-equipped to handle the algorithms for them without actually performing the division implied by the fraction. Thus, to use these types of functions an explicit call to asDecimal() must first be made on classes that implement Fraction . See Also The page for Types & Values > Decimals contains more information on the usage of Decimal values.","title":"Fraction"},{"location":"snippets/has-interface/hashable/","text":"Hashable namespace Ds The Hashable interface is part of ext-ds , and implementing it enables a class to be used as an array key in the various types provided by ext-ds .","title":"Hashable"},{"location":"snippets/has-interface/number/","text":"NumberInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers NumberInterface contains the base arithmetic methods that are a component of all numbers in mathematics. This includes the basics of addition, subtraction, multiplication, and division, as well as pow and square root. It also provides the isEqual() method, to enable equality comparison, as well as getScale() . Some classes which implement the NumberInterface don't actually accept scale as an argument, but instead contain objects that do. Fraction is an example of such a class, as both its numerator and denominator are instances of ImmutableDecimal . In addition, the is and as methods for Real , Imaginary , and Complex are provided by this interface.","title":"Number"},{"location":"snippets/has-interface/simple-number/","text":"SimpleNumberInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends NumberInterface The SimpleNumberInterface extends NumberInterface and adds the methods that are common to all non-complex numbers. This includes things like being positive or negative, inequality comparison, and getting the value as a base-10 real number.","title":"Simple number"},{"location":"snippets/uses-trait/arithmeticcomplex/","text":"ArithmeticComplexTrait namespace Samsara\\Fermat\\Types\\Traits uses ArithmeticScaleTrait ArithmeticNativeTrait ArithmeticSelectionTrat satisfies ComplexNumberInterface (partially) The ArithmeticComplexTrait provides the implementations for all arithmetic functions that exist on values that implement the ComplexNumberInterface . The additional imported traits within this trait provide the various calculation modes that are used internally depending on the mode of object executing the method call. Accepts Simple Numbers as Arguments While the ArithmeticComplexTrait can accept implementations of SimpleNumberInterface as arguments, it cannot be used in implementations of SimpleNumberInterface . See Also More detailed information on this trait is available on the Arithmetic > Complex Numbers page.","title":"Arithmeticcomplex"},{"location":"snippets/uses-trait/arithmeticsimple/","text":"ArithmeticSimpleTrait namespace Samsara\\Fermat\\Types\\Traits uses ArithmeticScaleTrait ArithmeticNativeTrait ArithmeticSelectionTrat satisfies SimpleNumberInterface (partially) The ArithmeticSimpleTrait provides the implementations for all arithmetic functions that exist on values that implement the SimpleNumberInterface . The additional imported traits within this trait provide the various calculation modes that are used internally depending on the mode of object executing the method call. Accepts Complex Numbers as Arguments While the ArithmeticSimpleTrait can accept implementations of ComplexNumber as arguments, it cannot be used in implementations of ComplexNumber . See Also More detailed information on this trait is available on the Arithmetic > Simple Numbers page.","title":"Arithmeticsimple"},{"location":"snippets/uses-trait/comparison/","text":"ComparisonTrait namespace Samsara\\Fermat\\Types\\Traits satisfies SimpleNumberInterface (partially) The ComparisonTrait provides the implementations of all comparison methods for any class which implements the SimpleNumberInterface .","title":"Comparison"},{"location":"snippets/uses-trait/integer-math/","text":"IntegerMathTrait namespace Samsara\\Fermat\\Types\\Traits satisfies DecimalInterface (partially) The IntegerMathTrait provides the implementations of all integer math methods for any class which implements the DecimalInterface . This includes methods such as factorial() and isPrime() .","title":"Integer math"},{"location":"snippets/uses-trait/inverse-trigonometry/","text":"InverseTrigonometryTrait namespace Samsara\\Fermat\\Types\\Traits\\Decimal satisfies DecimalInterface (partially) The InverseTrigonometryTrait provides the implementations for all inverse trigonometric functions, sometimes referred to as \"arc functions\". These are sometimes abbreviated in programming languages as a , such as atan which is equivalent to arctan which is equivalent to inverseTangent .","title":"Inverse trigonometry"},{"location":"snippets/uses-trait/log/","text":"LogTrait namespace Samsara\\Fermat\\Types\\Traits\\Decimal satisfies DecimalInterface (partially) The LogTrait provides the implementations for the log , ln , and exp functions.","title":"Log"},{"location":"snippets/uses-trait/scale/","text":"ScaleTrait namespace Samsara\\Fermat\\Types\\Traits\\Decimal satisfies DecimalInterface (partially) The ScaleTrait provides the implementations for all rounding and truncating functions for classes which implement DecimalInterface .","title":"Scale"},{"location":"snippets/uses-trait/trigonometry/","text":"TrigonometryTrait namespace Samsara\\Fermat\\Types\\Traits\\Decimal satisfies DecimalInterface (partially) The TrigonometryTrait provides the implementations for all basic trigonometry and hyperbolic trigonometry functions.","title":"Trigonometry"},{"location":"statistics/distributions/","text":"","title":"Using Distributions"},{"location":"statistics/included/","text":"","title":"Built In Distributions"},{"location":"statistics/static-methods/","text":"","title":"Using Static Methods"},{"location":"trigonometry/basic/","text":"Working with DecimalInterface Trigonometry methods are only available on objects which implement DecimalInterface . If you want to do trigonometry functions on an object that implement FractionInterface , calling the asDecimal() method will return the numerator divided by the denominator as an instance of ImmutableNumber which implements the DecimalInterface . All trigonometry methods in this library assume that the Value is in radians. sin(int $scale = null, bool $round = true): self This method applies the sin function to the current Value. If $scale is null, the scale setting of the object is used. If a scale of greater than 99 is supplied as an argument, or if the object has a scale of greater than 99, the scale is silently reduced to 99. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 5 $four = new ImmutableNumber ( 4 ); 6 $largeInt = new ImmutableNumber ( '1000000000000000000000000000' ); 7 8 echo $four -> sin (); // Prints: \"-0.7568024953\" 9 echo $largeInt -> sin ( 15 ); // Prints: \"0.718063496139118\" cos(int $scale = null, bool $round = true): self This method applies the cos function to the current Value. If $scale is null, the scale setting of the object is used. If a scale of greater than 99 is supplied as an argument, or if the object has a scale of greater than 99, the scale is silently reduced to 99. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 5 $four = new ImmutableNumber ( 4 ); 6 $largeInt = new ImmutableNumber ( '1000000000000000000000000000' ); 7 8 echo $four -> cos (); // Prints: \"-0.6536436209\" 9 echo $largeInt -> cos ( 15 ); // Prints: \"-0.695977596990354\" tan(int $scale = null, bool $round = true): self This method applies the tan function to the current Value. If $scale is null, the scale setting of the object is used. If a scale of greater than 99 is supplied as an argument, or if the object has a scale of greater than 99, the scale is silently reduced to 99. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 5 $twoPiDivThree = Numbers :: make2Pi () -> divide ( 3 ); 6 $piDivTwo = Numbers :: makePi () -> divide ( 2 ); 7 8 echo $twoPiDivThree -> tan ( 14 ); // Prints: \"-1.73205080756888\" 9 echo $twoPiDivThree -> tan ( 14 , false ); // Prints: \"-1.73205080756887\" 10 echo $piDivTwo -> tan (); // Prints: \"INF\" cot(int $scale = null, bool $round = true): self This method applies the cot function to the current Value. If $scale is null, the scale setting of the object is used. If a scale of greater than 99 is supplied as an argument, or if the object has a scale of greater than 99, the scale is silently reduced to 99. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 5 $five = new ImmutableNumber ( 5 ); 6 7 echo $five -> cot ( 9 ); // Prints: \"-0.295812916\" 8 echo $five -> cot ( 9 , false ); // Prints: \"-0.295812915\" sec(int $scale = null, bool $round = true): self This method applies the sec function to the current Value. If $scale is null, the scale setting of the object is used. If a scale of greater than 99 is supplied as an argument, or if the object has a scale of greater than 99, the scale is silently reduced to 99. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 5 $five = new ImmutableNumber ( 5 ); 6 7 echo $five -> sec ( 9 ); // Prints: \"3.525320086\" 8 echo $five -> sec ( 9 , false ); // Prints: \"3.525320085\" csc(int $scale = null, bool $round = true): self This method applies the csc function to the current Value. If $scale is null, the scale setting of the object is used. If a scale of greater than 99 is supplied as an argument, or if the object has a scale of greater than 99, the scale is silently reduced to 99. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 5 $five = new ImmutableNumber ( 5 ); 6 7 echo $five -> csc ( 9 ); // Prints: \"-1.042835213\" 8 echo $five -> csc ( 9 , false ); // Prints: \"-1.042835212\" arcsin(int $scale = null, bool $round = true): self This method applies the arcsin function to the current Value. If $scale is null, the scale setting of the object is used. If a scale of greater than 99 is supplied as an argument, or if the object has a scale of greater than 99, the scale is silently reduced to 99. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. Note: The arcsin() function has a domain of \u22121 \u2264 x \u2264 1 and a range of \u2212\u03c0/2 \u2264 y \u2264 \u03c0/2. arccos(int $scale = null, bool $round = true): self This method applies the arccos function to the current Value. If $scale is null, the scale setting of the object is used. If a scale of greater than 99 is supplied as an argument, or if the object has a scale of greater than 99, the scale is silently reduced to 99. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. Note: The arccos() function has a domain of \u22121 \u2264 x \u2264 1 and a range of 0 \u2264 y \u2264 \u03c0. arctan(int $scale = null, bool $round = true): self This method applies the arctan function to the current Value. If $scale is null, the scale setting of the object is used. If a scale of greater than 99 is supplied as an argument, or if the object has a scale of greater than 99, the scale is silently reduced to 99. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. Note: The arctan() function has a domain of all real numbers and a range of -\u03c0/2 < y < \u03c0/2. 1 <?php 2 3 use Samsara\\Fermat\\Values\\ImmutableNumber ; 4 5 $five = new ImmutableNumber ( 5 ); 6 7 echo $five -> arctan ( 9 ); // Prints: \"1.373400767\" 8 echo $five -> arctan ( 9 , false ); // Prints: \"1.373400767\" arccot(int $scale = null, bool $round = true): self This method applies the arccot function to the current Value. If $scale is null, the scale setting of the object is used. If a scale of greater than 99 is supplied as an argument, or if the object has a scale of greater than 99, the scale is silently reduced to 99. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. Note: The arccot() function has a domain of all real numbers and a range of 0 < y < \u03c0. arcsec(int $scale = null, bool $round = true): self This method applies the arcsec function to the current Value. If $scale is null, the scale setting of the object is used. If a scale of greater than 99 is supplied as an argument, or if the object has a scale of greater than 99, the scale is silently reduced to 99. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. Note: The arcsec() function has a domain of x \u2264 \u22121 or 1 \u2264 x and a range of 0 \u2264 y < \u03c0/2 or \u03c0/2 < y \u2264 \u03c0. arccsc(int $scale = null, bool $round = true): self This method applies the arccsc function to the current Value. If $scale is null, the scale setting of the object is used. If a scale of greater than 99 is supplied as an argument, or if the object has a scale of greater than 99, the scale is silently reduced to 99. If the $round argument is true the last digit will be rounded; if the $round argument is false the last digit will be truncated. It is important to note that the last digit (prior to rounding) is guaranteed to be accurate, so rounding will actually reduce the scale, in effect, by one. However, it will capture some of the behavior after the scale limit. Note: The arccsc() function has a domain of x \u2264 \u22121 or 1 \u2264 x and a range of \u2212\u03c0/2 \u2264 y < 0 or 0 < y \u2264 \u03c0/2.","title":"Basic Trig Functions"},{"location":"trigonometry/basic/#working-with-decimalinterface","text":"Trigonometry methods are only available on objects which implement DecimalInterface . If you want to do trigonometry functions on an object that implement FractionInterface , calling the asDecimal() method will return the numerator divided by the denominator as an instance of ImmutableNumber which implements the DecimalInterface . All trigonometry methods in this library assume that the Value is in radians.","title":"Working with DecimalInterface"},{"location":"trigonometry/hyperbolic/","text":"","title":"Hyperbolic Trig Functions"},{"location":"trigonometry/inverse/","text":"","title":"Inverse Trig Functions"},{"location":"trigonometry/traits/","text":"","title":"Built In Traits"},{"location":"types-and-values/collections/","text":"","title":"Collections"},{"location":"types-and-values/complex/","text":"","title":"Complex Numbers"},{"location":"types-and-values/coordinates/","text":"","title":"Coordinates"},{"location":"types-and-values/decimals/","text":".katex img { object-fit: fill; padding: unset; display: block; position: absolute; width: 100%; height: inherit; } Decimals represent numbers which have a decimal representation. They can be equivalent to either a float or an integer , and their $scale setting determines how many places after the decimal are calculated for operations which would affect them. Abstract Class: Decimal The following interfaces and traits are available on classes which extend Decimal Interfaces Hashable namespace Ds The Hashable interface is part of ext-ds , and implementing it enables a class to be used as an array key in the various types provided by ext-ds . BaseConversionInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Characteristics BaseConversionInterface enables two methods: convertToBase() and getBase() , which do exactly what someone would expect them to. Base Conversion is Done Just-In-Time Internally, the values of objects which implement the BaseConversionInterface always store the number in base-10, since this is the only base that arithmetic can actually be performed in by any of the associated extensions. Base conversion happens when a call is made to getValue() . Even on objects which have a base other than base-10, this can be avoided by calls to getAsBaseTenNumber() and getAsBaseTenRealNumber() . NumberInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers NumberInterface contains the base arithmetic methods that are a component of all numbers in mathematics. This includes the basics of addition, subtraction, multiplication, and division, as well as pow and square root. It also provides the isEqual() method, to enable equality comparison, as well as getScale() . Some classes which implement the NumberInterface don't actually accept scale as an argument, but instead contain objects that do. Fraction is an example of such a class, as both its numerator and denominator are instances of ImmutableDecimal . In addition, the is and as methods for Real , Imaginary , and Complex are provided by this interface. SimpleNumberInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends NumberInterface The SimpleNumberInterface extends NumberInterface and adds the methods that are common to all non-complex numbers. This includes things like being positive or negative, inequality comparison, and getting the value as a base-10 real number. DecimalInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends SimpleNumberInterface which extends NumberInterface The DecimalInterface extends SimpleNumberInterface and adds the methods that are common to all decimal values. This includes trigonometric operations, integer operations such as factorial() or isPrime() , integer and float comparisons and conversions, rounding and truncating functions, and log functions. While some of these can be done on fractions in pure mathematics, such as trigonometry functions, in practice computers are not well-equipped to handle the algorithms for them without actually performing the division implied by the fraction. Thus, to use these types of functions an explicit call to asDecimal() must first be made on classes that implement Fraction . See Also The page for Types & Values > Fractions contains more information on the limitations of fraction representations within Fermat. Traits ArithmeticSimpleTrait namespace Samsara\\Fermat\\Types\\Traits uses ArithmeticScaleTrait ArithmeticNativeTrait ArithmeticSelectionTrat satisfies SimpleNumberInterface (partially) The ArithmeticSimpleTrait provides the implementations for all arithmetic functions that exist on values that implement the SimpleNumberInterface . The additional imported traits within this trait provide the various calculation modes that are used internally depending on the mode of object executing the method call. Accepts Complex Numbers as Arguments While the ArithmeticSimpleTrait can accept implementations of ComplexNumber as arguments, it cannot be used in implementations of ComplexNumber . See Also More detailed information on this trait is available on the Arithmetic > Simple Numbers page. ComparisonTrait namespace Samsara\\Fermat\\Types\\Traits satisfies SimpleNumberInterface (partially) The ComparisonTrait provides the implementations of all comparison methods for any class which implements the SimpleNumberInterface . IntegerMathTrait namespace Samsara\\Fermat\\Types\\Traits satisfies DecimalInterface (partially) The IntegerMathTrait provides the implementations of all integer math methods for any class which implements the DecimalInterface . This includes methods such as factorial() and isPrime() . TrigonometryTrait namespace Samsara\\Fermat\\Types\\Traits\\Decimal satisfies DecimalInterface (partially) The TrigonometryTrait provides the implementations for all basic trigonometry and hyperbolic trigonometry functions. InverseTrigonometryTrait namespace Samsara\\Fermat\\Types\\Traits\\Decimal satisfies DecimalInterface (partially) The InverseTrigonometryTrait provides the implementations for all inverse trigonometric functions, sometimes referred to as \"arc functions\". These are sometimes abbreviated in programming languages as a , such as atan which is equivalent to arctan which is equivalent to inverseTangent . LogTrait namespace Samsara\\Fermat\\Types\\Traits\\Decimal satisfies DecimalInterface (partially) The LogTrait provides the implementations for the log , ln , and exp functions. ScaleTrait namespace Samsara\\Fermat\\Types\\Traits\\Decimal satisfies DecimalInterface (partially) The ScaleTrait provides the implementations for all rounding and truncating functions for classes which implement DecimalInterface . Abstract Methods The following abstract methods must be implemented on classes which extend Decimal abstract protected function setValue(string $value, int $scale = null, int $base = 10) $value The new value that will be set in the same format as the output of getValue(10) $scale The maximum number of digits after the decimal that the value can contain $base The base of the value in the final instance return An instance of the current class with the given arguments set as properties This method controls the behavior of setting the $value property, and its different implementations represent the main difference between mutable and immutable versions. abstract public function continuousModulo($mod): DecimalInterface $mod The modulus that will be taken; the base which will be used to calculate the remainder; can be a decimal value return The remainder of dividing the current value by the $mod This method comes from DecimalInterface and must be implemented by the extending class. This is because it might be undesirable for this method to be mutable, even for a mutable class. It takes a decimal value as its input, and returns the remainder of a division operation, even if the number provided is not an integer. Available Value Objects The following implementations of Decimal are included with Fermat. These classes may be provided for any argument which accepts a DecimalInterface as a value. ImmutableDecimal A number which can be represented as a decimal and has a maximum scale of 2 63 2^{63} 2 63 digits. This value is immutable, and all methods called on instances of the class will return a new instance of the same class while leaving the existing instance at its original value. MutableDecimal A number which can be represented as a decimal and has a maximum scale of 2 63 2^{63} 2 63 digits. This value is mutable, and all methods called on instances of the class will return the same instance after modification, while the previous value will be lost.","title":"Decimals"},{"location":"types-and-values/decimals/#abstract-class-decimal","text":"The following interfaces and traits are available on classes which extend Decimal","title":"Abstract Class: Decimal"},{"location":"types-and-values/decimals/#interfaces","text":"Hashable namespace Ds The Hashable interface is part of ext-ds , and implementing it enables a class to be used as an array key in the various types provided by ext-ds . BaseConversionInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Characteristics BaseConversionInterface enables two methods: convertToBase() and getBase() , which do exactly what someone would expect them to. Base Conversion is Done Just-In-Time Internally, the values of objects which implement the BaseConversionInterface always store the number in base-10, since this is the only base that arithmetic can actually be performed in by any of the associated extensions. Base conversion happens when a call is made to getValue() . Even on objects which have a base other than base-10, this can be avoided by calls to getAsBaseTenNumber() and getAsBaseTenRealNumber() . NumberInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers NumberInterface contains the base arithmetic methods that are a component of all numbers in mathematics. This includes the basics of addition, subtraction, multiplication, and division, as well as pow and square root. It also provides the isEqual() method, to enable equality comparison, as well as getScale() . Some classes which implement the NumberInterface don't actually accept scale as an argument, but instead contain objects that do. Fraction is an example of such a class, as both its numerator and denominator are instances of ImmutableDecimal . In addition, the is and as methods for Real , Imaginary , and Complex are provided by this interface. SimpleNumberInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends NumberInterface The SimpleNumberInterface extends NumberInterface and adds the methods that are common to all non-complex numbers. This includes things like being positive or negative, inequality comparison, and getting the value as a base-10 real number. DecimalInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends SimpleNumberInterface which extends NumberInterface The DecimalInterface extends SimpleNumberInterface and adds the methods that are common to all decimal values. This includes trigonometric operations, integer operations such as factorial() or isPrime() , integer and float comparisons and conversions, rounding and truncating functions, and log functions. While some of these can be done on fractions in pure mathematics, such as trigonometry functions, in practice computers are not well-equipped to handle the algorithms for them without actually performing the division implied by the fraction. Thus, to use these types of functions an explicit call to asDecimal() must first be made on classes that implement Fraction . See Also The page for Types & Values > Fractions contains more information on the limitations of fraction representations within Fermat.","title":"Interfaces"},{"location":"types-and-values/decimals/#traits","text":"ArithmeticSimpleTrait namespace Samsara\\Fermat\\Types\\Traits uses ArithmeticScaleTrait ArithmeticNativeTrait ArithmeticSelectionTrat satisfies SimpleNumberInterface (partially) The ArithmeticSimpleTrait provides the implementations for all arithmetic functions that exist on values that implement the SimpleNumberInterface . The additional imported traits within this trait provide the various calculation modes that are used internally depending on the mode of object executing the method call. Accepts Complex Numbers as Arguments While the ArithmeticSimpleTrait can accept implementations of ComplexNumber as arguments, it cannot be used in implementations of ComplexNumber . See Also More detailed information on this trait is available on the Arithmetic > Simple Numbers page. ComparisonTrait namespace Samsara\\Fermat\\Types\\Traits satisfies SimpleNumberInterface (partially) The ComparisonTrait provides the implementations of all comparison methods for any class which implements the SimpleNumberInterface . IntegerMathTrait namespace Samsara\\Fermat\\Types\\Traits satisfies DecimalInterface (partially) The IntegerMathTrait provides the implementations of all integer math methods for any class which implements the DecimalInterface . This includes methods such as factorial() and isPrime() . TrigonometryTrait namespace Samsara\\Fermat\\Types\\Traits\\Decimal satisfies DecimalInterface (partially) The TrigonometryTrait provides the implementations for all basic trigonometry and hyperbolic trigonometry functions. InverseTrigonometryTrait namespace Samsara\\Fermat\\Types\\Traits\\Decimal satisfies DecimalInterface (partially) The InverseTrigonometryTrait provides the implementations for all inverse trigonometric functions, sometimes referred to as \"arc functions\". These are sometimes abbreviated in programming languages as a , such as atan which is equivalent to arctan which is equivalent to inverseTangent . LogTrait namespace Samsara\\Fermat\\Types\\Traits\\Decimal satisfies DecimalInterface (partially) The LogTrait provides the implementations for the log , ln , and exp functions. ScaleTrait namespace Samsara\\Fermat\\Types\\Traits\\Decimal satisfies DecimalInterface (partially) The ScaleTrait provides the implementations for all rounding and truncating functions for classes which implement DecimalInterface .","title":"Traits"},{"location":"types-and-values/decimals/#abstract-methods","text":"The following abstract methods must be implemented on classes which extend Decimal abstract protected function setValue(string $value, int $scale = null, int $base = 10) $value The new value that will be set in the same format as the output of getValue(10) $scale The maximum number of digits after the decimal that the value can contain $base The base of the value in the final instance return An instance of the current class with the given arguments set as properties This method controls the behavior of setting the $value property, and its different implementations represent the main difference between mutable and immutable versions. abstract public function continuousModulo($mod): DecimalInterface $mod The modulus that will be taken; the base which will be used to calculate the remainder; can be a decimal value return The remainder of dividing the current value by the $mod This method comes from DecimalInterface and must be implemented by the extending class. This is because it might be undesirable for this method to be mutable, even for a mutable class. It takes a decimal value as its input, and returns the remainder of a division operation, even if the number provided is not an integer.","title":"Abstract Methods"},{"location":"types-and-values/decimals/#available-value-objects","text":"The following implementations of Decimal are included with Fermat. These classes may be provided for any argument which accepts a DecimalInterface as a value.","title":"Available Value Objects"},{"location":"types-and-values/decimals/#immutabledecimal","text":"A number which can be represented as a decimal and has a maximum scale of 2 63 2^{63} 2 63 digits. This value is immutable, and all methods called on instances of the class will return a new instance of the same class while leaving the existing instance at its original value.","title":"ImmutableDecimal"},{"location":"types-and-values/decimals/#mutabledecimal","text":"A number which can be represented as a decimal and has a maximum scale of 2 63 2^{63} 2 63 digits. This value is mutable, and all methods called on instances of the class will return the same instance after modification, while the previous value will be lost.","title":"MutableDecimal"},{"location":"types-and-values/expressions/","text":"","title":"Expressions"},{"location":"types-and-values/fractions/","text":"Fractions represent numbers which have a rational representation. They can be equivalent to either a float or an integer , and their $scale setting is determined by the scale setting of the Decimal instances that make up their numerator and denominator. Abstract Class: Fraction The following interfaces and traits are available on classes which extend Fraction Interfaces Hashable namespace Ds The Hashable interface is part of ext-ds , and implementing it enables a class to be used as an array key in the various types provided by ext-ds . BaseConversionInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Characteristics BaseConversionInterface enables two methods: convertToBase() and getBase() , which do exactly what someone would expect them to. Base Conversion is Done Just-In-Time Internally, the values of objects which implement the BaseConversionInterface always store the number in base-10, since this is the only base that arithmetic can actually be performed in by any of the associated extensions. Base conversion happens when a call is made to getValue() . Even on objects which have a base other than base-10, this can be avoided by calls to getAsBaseTenNumber() and getAsBaseTenRealNumber() . NumberInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers NumberInterface contains the base arithmetic methods that are a component of all numbers in mathematics. This includes the basics of addition, subtraction, multiplication, and division, as well as pow and square root. It also provides the isEqual() method, to enable equality comparison, as well as getScale() . Some classes which implement the NumberInterface don't actually accept scale as an argument, but instead contain objects that do. Fraction is an example of such a class, as both its numerator and denominator are instances of ImmutableDecimal . In addition, the is and as methods for Real , Imaginary , and Complex are provided by this interface. SimpleNumberInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends NumberInterface The SimpleNumberInterface extends NumberInterface and adds the methods that are common to all non-complex numbers. This includes things like being positive or negative, inequality comparison, and getting the value as a base-10 real number. FractionInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends SimpleNumberInterface which extends NumberInterface The FractionInterface extends SimpleNumberInterface and adds the methods that are common to all fraction values. This includes simplify() , accessors for the numerator and denominator, and the asDecimal() method that returns the Fraction as an instance of DecimalInterface . ImmutableDecimals Are Returned From asDecimal() While the interface only defines the DecimalInterface as a return value, the concrete classes returned by all included implementations are instances of ImmutableDecimal . While some other functions can be done on fractions in pure mathematics, such as trigonometry functions, in practice computers are not well-equipped to handle the algorithms for them without actually performing the division implied by the fraction. Thus, to use these types of functions an explicit call to asDecimal() must first be made on classes that implement Fraction . See Also The page for Types & Values > Decimals contains more information on the usage of Decimal values. Traits ArithmeticSimpleTrait namespace Samsara\\Fermat\\Types\\Traits uses ArithmeticScaleTrait ArithmeticNativeTrait ArithmeticSelectionTrat satisfies SimpleNumberInterface (partially) The ArithmeticSimpleTrait provides the implementations for all arithmetic functions that exist on values that implement the SimpleNumberInterface . The additional imported traits within this trait provide the various calculation modes that are used internally depending on the mode of object executing the method call. Accepts Complex Numbers as Arguments While the ArithmeticSimpleTrait can accept implementations of ComplexNumber as arguments, it cannot be used in implementations of ComplexNumber . See Also More detailed information on this trait is available on the Arithmetic > Simple Numbers page. ComparisonTrait namespace Samsara\\Fermat\\Types\\Traits satisfies SimpleNumberInterface (partially) The ComparisonTrait provides the implementations of all comparison methods for any class which implements the SimpleNumberInterface . Abstract Methods The following abstract methods must be implemented on classes which extend Fraction abstract protected function setValue(ImmutableDecimal $numerator, ImmutableDecimal $denominator) $numerator The new numerator value, given as an instance of ImmutableDecimal $denominator The new denominator value, given as an instance of ImmutableDecimal return An instance of the current class with the given arguments set as properties This method controls the behavior of setting the $value property, and its different implementations represent the main difference between mutable and immutable versions. For classes that extend Fraction , the arguments are limited to the concrete class ImmutableDecimal . Available Value Objects The following implementations of Fraction are included with Fermat. These classes may be provided for any argument which accepts a FractionInterface as a value. ImmutableFraction A number which can be represented as a fraction. This value is immutable, and all methods called on instances of the class will return a new instance of the same class while leaving the existing instance at its original value. MutableFraction A number which can be represented as a fraction. This value is mutable, and all methods called on instances of the class will return the same instance after modification, while the previous value will be lost.","title":"Fractions"},{"location":"types-and-values/fractions/#abstract-class-fraction","text":"The following interfaces and traits are available on classes which extend Fraction","title":"Abstract Class: Fraction"},{"location":"types-and-values/fractions/#interfaces","text":"Hashable namespace Ds The Hashable interface is part of ext-ds , and implementing it enables a class to be used as an array key in the various types provided by ext-ds . BaseConversionInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Characteristics BaseConversionInterface enables two methods: convertToBase() and getBase() , which do exactly what someone would expect them to. Base Conversion is Done Just-In-Time Internally, the values of objects which implement the BaseConversionInterface always store the number in base-10, since this is the only base that arithmetic can actually be performed in by any of the associated extensions. Base conversion happens when a call is made to getValue() . Even on objects which have a base other than base-10, this can be avoided by calls to getAsBaseTenNumber() and getAsBaseTenRealNumber() . NumberInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers NumberInterface contains the base arithmetic methods that are a component of all numbers in mathematics. This includes the basics of addition, subtraction, multiplication, and division, as well as pow and square root. It also provides the isEqual() method, to enable equality comparison, as well as getScale() . Some classes which implement the NumberInterface don't actually accept scale as an argument, but instead contain objects that do. Fraction is an example of such a class, as both its numerator and denominator are instances of ImmutableDecimal . In addition, the is and as methods for Real , Imaginary , and Complex are provided by this interface. SimpleNumberInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends NumberInterface The SimpleNumberInterface extends NumberInterface and adds the methods that are common to all non-complex numbers. This includes things like being positive or negative, inequality comparison, and getting the value as a base-10 real number. FractionInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends SimpleNumberInterface which extends NumberInterface The FractionInterface extends SimpleNumberInterface and adds the methods that are common to all fraction values. This includes simplify() , accessors for the numerator and denominator, and the asDecimal() method that returns the Fraction as an instance of DecimalInterface . ImmutableDecimals Are Returned From asDecimal() While the interface only defines the DecimalInterface as a return value, the concrete classes returned by all included implementations are instances of ImmutableDecimal . While some other functions can be done on fractions in pure mathematics, such as trigonometry functions, in practice computers are not well-equipped to handle the algorithms for them without actually performing the division implied by the fraction. Thus, to use these types of functions an explicit call to asDecimal() must first be made on classes that implement Fraction . See Also The page for Types & Values > Decimals contains more information on the usage of Decimal values.","title":"Interfaces"},{"location":"types-and-values/fractions/#traits","text":"ArithmeticSimpleTrait namespace Samsara\\Fermat\\Types\\Traits uses ArithmeticScaleTrait ArithmeticNativeTrait ArithmeticSelectionTrat satisfies SimpleNumberInterface (partially) The ArithmeticSimpleTrait provides the implementations for all arithmetic functions that exist on values that implement the SimpleNumberInterface . The additional imported traits within this trait provide the various calculation modes that are used internally depending on the mode of object executing the method call. Accepts Complex Numbers as Arguments While the ArithmeticSimpleTrait can accept implementations of ComplexNumber as arguments, it cannot be used in implementations of ComplexNumber . See Also More detailed information on this trait is available on the Arithmetic > Simple Numbers page. ComparisonTrait namespace Samsara\\Fermat\\Types\\Traits satisfies SimpleNumberInterface (partially) The ComparisonTrait provides the implementations of all comparison methods for any class which implements the SimpleNumberInterface .","title":"Traits"},{"location":"types-and-values/fractions/#abstract-methods","text":"The following abstract methods must be implemented on classes which extend Fraction abstract protected function setValue(ImmutableDecimal $numerator, ImmutableDecimal $denominator) $numerator The new numerator value, given as an instance of ImmutableDecimal $denominator The new denominator value, given as an instance of ImmutableDecimal return An instance of the current class with the given arguments set as properties This method controls the behavior of setting the $value property, and its different implementations represent the main difference between mutable and immutable versions. For classes that extend Fraction , the arguments are limited to the concrete class ImmutableDecimal .","title":"Abstract Methods"},{"location":"types-and-values/fractions/#available-value-objects","text":"The following implementations of Fraction are included with Fermat. These classes may be provided for any argument which accepts a FractionInterface as a value.","title":"Available Value Objects"},{"location":"types-and-values/fractions/#immutablefraction","text":"A number which can be represented as a fraction. This value is immutable, and all methods called on instances of the class will return a new instance of the same class while leaving the existing instance at its original value.","title":"ImmutableFraction"},{"location":"types-and-values/fractions/#mutablefraction","text":"A number which can be represented as a fraction. This value is mutable, and all methods called on instances of the class will return the same instance after modification, while the previous value will be lost.","title":"MutableFraction"},{"location":"types-and-values/matrices/","text":"","title":"Matrices"},{"location":"types-and-values/template/","text":"test test test pow(mixed $num): NumberInterface $num This is a description of the $num argument return The return desc ComplexNumbers::IMMUTABLE_COMPLEX type string value The fully qualified class name of the ImmutableComplexNumber class. DecimalInterface namespace Samsara\\Fermat\\Types\\Base\\Interfaces\\Numbers extends SimpleNumberInterface which extends NumberInterface ArithmeticSimpleTrait namespace Samsara\\Fermat\\Types\\Traits uses ArithmeticScaleTrait ArithmeticNativeTrait ArithmeticSelectionTrat satisfies SimpleNumberInterface (partially)","title":"Template"}]}